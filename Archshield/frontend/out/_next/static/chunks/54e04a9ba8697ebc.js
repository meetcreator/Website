(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push(["object" == typeof document ? document.currentScript : void 0, 8139, (e, t, n) => { "use strict"; var o = e.r(6522), r = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, i = o.useState, a = o.useEffect, l = o.useLayoutEffect, s = o.useDebugValue; function u(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !r(e, n) } catch (e) { return !0 } } var c = "u" < typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), o = i({ inst: { value: n, getSnapshot: t } }), r = o[0].inst, c = o[1]; return l(function () { r.value = n, r.getSnapshot = t, u(r) && c({ inst: r }) }, [e, n, t]), a(function () { return u(r) && c({ inst: r }), e(function () { u(r) && c({ inst: r }) }) }, [e]), s(n), n }; n.useSyncExternalStore = void 0 !== o.useSyncExternalStore ? o.useSyncExternalStore : c }, 32779, (e, t, n) => { "use strict"; t.exports = e.r(8139) }, 22754, (e, t, n) => { "use strict"; var o = e.r(6522), r = e.r(32779), i = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, a = r.useSyncExternalStore, l = o.useRef, s = o.useEffect, u = o.useMemo, c = o.useDebugValue; n.useSyncExternalStoreWithSelector = function (e, t, n, o, r) { var d = l(null); if (null === d.current) { var h = { hasValue: !1, value: null }; d.current = h } else h = d.current; var f = a(e, (d = u(function () { function e(e) { if (!s) { if (s = !0, a = e, e = o(e), void 0 !== r && h.hasValue) { var t = h.value; if (r(t, e)) return l = t } return l = e } if (t = l, i(a, e)) return t; var n = o(e); return void 0 !== r && r(t, n) ? (a = e, t) : (a = e, l = n) } var a, l, s = !1, u = void 0 === n ? null : n; return [function () { return e(t()) }, null === u ? void 0 : function () { return e(u()) }] }, [t, n, o, r]))[0], d[1]); return s(function () { h.hasValue = !0, h.value = f }, [f]), c(f), f } }, 45854, (e, t, n) => { "use strict"; t.exports = e.r(22754) }, 11477, e => {
        "use strict"; var t, n, o, r, i, a, l, s, u, c, d, h, f, p, g, m, y, x = e.i(98649), v = e.i(68602), b = e.i(6522); function w(e) { if ("string" == typeof e || "number" == typeof e) return "" + e; let t = ""; if (Array.isArray(e)) for (let n = 0, o; n < e.length; n++)"" !== (o = w(e[n])) && (t += (t && " ") + o); else for (let n in e) e[n] && (t += (t && " ") + n); return t } var S = { value: () => { } }; function _() { for (var e, t = 0, n = arguments.length, o = {}; t < n; ++t) { if (!(e = arguments[t] + "") || e in o || /[\s.]/.test(e)) throw Error("illegal type: " + e); o[e] = [] } return new M(o) } function M(e) { this._ = e } function E(e, t, n) { for (var o = 0, r = e.length; o < r; ++o)if (e[o].name === t) { e[o] = S, e = e.slice(0, o).concat(e.slice(o + 1)); break } return null != n && e.push({ name: t, value: n }), e } function k() { } function C(e) { return null == e ? k : function () { return this.querySelector(e) } } function N() { return [] } function A(e) { return null == e ? N : function () { return this.querySelectorAll(e) } } function j(e) { return function () { return this.matches(e) } } function P(e) { return function (t) { return t.matches(e) } } M.prototype = _.prototype = { constructor: M, on: function (e, t) { var n, o = this._, r = (e + "").trim().split(/^|\s+/).map(function (e) { var t = "", n = e.indexOf("."); if (n >= 0 && (t = e.slice(n + 1), e = e.slice(0, n)), e && !o.hasOwnProperty(e)) throw Error("unknown type: " + e); return { type: e, name: t } }), i = -1, a = r.length; if (arguments.length < 2) { for (; ++i < a;)if ((n = (e = r[i]).type) && (n = function (e, t) { for (var n, o = 0, r = e.length; o < r; ++o)if ((n = e[o]).name === t) return n.value }(o[n], e.name))) return n; return } if (null != t && "function" != typeof t) throw Error("invalid callback: " + t); for (; ++i < a;)if (n = (e = r[i]).type) o[n] = E(o[n], e.name, t); else if (null == t) for (n in o) o[n] = E(o[n], e.name, null); return this }, copy: function () { var e = {}, t = this._; for (var n in t) e[n] = t[n].slice(); return new M(e) }, call: function (e, t) { if ((n = arguments.length - 2) > 0) for (var n, o, r = Array(n), i = 0; i < n; ++i)r[i] = arguments[i + 2]; if (!this._.hasOwnProperty(e)) throw Error("unknown type: " + e); for (o = this._[e], i = 0, n = o.length; i < n; ++i)o[i].value.apply(t, r) }, apply: function (e, t, n) { if (!this._.hasOwnProperty(e)) throw Error("unknown type: " + e); for (var o = this._[e], r = 0, i = o.length; r < i; ++r)o[r].value.apply(t, n) } }; var z = Array.prototype.find; function $() { return this.firstElementChild } var D = Array.prototype.filter; function I() { return Array.from(this.children) } function T(e) { return Array(e.length) } function R(e, t) { this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t } function L(e, t, n, o, r, i) { for (var a, l = 0, s = t.length, u = i.length; l < u; ++l)(a = t[l]) ? (a.__data__ = i[l], o[l] = a) : n[l] = new R(e, i[l]); for (; l < s; ++l)(a = t[l]) && (r[l] = a) } function O(e, t, n, o, r, i, a) { var l, s, u, c = new Map, d = t.length, h = i.length, f = Array(d); for (l = 0; l < d; ++l)(s = t[l]) && (f[l] = u = a.call(s, s.__data__, l, t) + "", c.has(u) ? r[l] = s : c.set(u, s)); for (l = 0; l < h; ++l)u = a.call(e, i[l], l, i) + "", (s = c.get(u)) ? (o[l] = s, s.__data__ = i[l], c.delete(u)) : n[l] = new R(e, i[l]); for (l = 0; l < d; ++l)(s = t[l]) && c.get(f[l]) === s && (r[l] = s) } function B(e) { return e.__data__ } function V(e, t) { return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN } R.prototype = { constructor: R, appendChild: function (e) { return this._parent.insertBefore(e, this._next) }, insertBefore: function (e, t) { return this._parent.insertBefore(e, t) }, querySelector: function (e) { return this._parent.querySelector(e) }, querySelectorAll: function (e) { return this._parent.querySelectorAll(e) } }; var H = "http://www.w3.org/1999/xhtml"; let F = { svg: "http://www.w3.org/2000/svg", xhtml: H, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }; function X(e) { var t = e += "", n = t.indexOf(":"); return n >= 0 && "xmlns" !== (t = e.slice(0, n)) && (e = e.slice(n + 1)), F.hasOwnProperty(t) ? { space: F[t], local: e } : e } function Y(e) { return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView } function Z(e, t) { return e.style.getPropertyValue(t) || Y(e).getComputedStyle(e, null).getPropertyValue(t) } function K(e) { return e.trim().split(/^|\s+/) } function q(e) { return e.classList || new W(e) } function W(e) { this._node = e, this._names = K(e.getAttribute("class") || "") } function U(e, t) { for (var n = q(e), o = -1, r = t.length; ++o < r;)n.add(t[o]) } function G(e, t) { for (var n = q(e), o = -1, r = t.length; ++o < r;)n.remove(t[o]) } function Q() { this.textContent = "" } function J() { this.innerHTML = "" } function ee() { this.nextSibling && this.parentNode.appendChild(this) } function et() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild) } function en(e) { var t = X(e); return (t.local ? function (e) { return function () { return this.ownerDocument.createElementNS(e.space, e.local) } } : function (e) { return function () { var t = this.ownerDocument, n = this.namespaceURI; return n === H && t.documentElement.namespaceURI === H ? t.createElement(e) : t.createElementNS(n, e) } })(t) } function eo() { return null } function er() { var e = this.parentNode; e && e.removeChild(this) } function ei() { var e = this.cloneNode(!1), t = this.parentNode; return t ? t.insertBefore(e, this.nextSibling) : e } function ea() { var e = this.cloneNode(!0), t = this.parentNode; return t ? t.insertBefore(e, this.nextSibling) : e } function el(e) { return function () { var t = this.__on; if (t) { for (var n, o = 0, r = -1, i = t.length; o < i; ++o)(n = t[o], e.type && n.type !== e.type || n.name !== e.name) ? t[++r] = n : this.removeEventListener(n.type, n.listener, n.options); ++r ? t.length = r : delete this.__on } } } function es(e, t, n) { return function () { var o, r = this.__on, i = function (e) { t.call(this, e, this.__data__) }; if (r) { for (var a = 0, l = r.length; a < l; ++a)if ((o = r[a]).type === e.type && o.name === e.name) { this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = i, o.options = n), o.value = t; return } } this.addEventListener(e.type, i, n), o = { type: e.type, name: e.name, value: t, listener: i, options: n }, r ? r.push(o) : this.__on = [o] } } function eu(e, t, n) { var o = Y(e), r = o.CustomEvent; "function" == typeof r ? r = new r(t, n) : (r = o.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r) } W.prototype = { add: function (e) { 0 > this._names.indexOf(e) && (this._names.push(e), this._node.setAttribute("class", this._names.join(" "))) }, remove: function (e) { var t = this._names.indexOf(e); t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" "))) }, contains: function (e) { return this._names.indexOf(e) >= 0 } }; var ec = [null]; function ed(e, t) { this._groups = e, this._parents = t } function eh() { return new ed([[document.documentElement]], ec) } function ef(e) { return "string" == typeof e ? new ed([[document.querySelector(e)]], [document.documentElement]) : new ed([[e]], ec) } function ep(e, t) { if (e = function (e) { let t; for (; t = e.sourceEvent;)e = t; return e }(e), void 0 === t && (t = e.currentTarget), t) { var n = t.ownerSVGElement || t; if (n.createSVGPoint) { var o = n.createSVGPoint(); return o.x = e.clientX, o.y = e.clientY, [(o = o.matrixTransform(t.getScreenCTM().inverse())).x, o.y] } if (t.getBoundingClientRect) { var r = t.getBoundingClientRect(); return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop] } } return [e.pageX, e.pageY] } ed.prototype = eh.prototype = { constructor: ed, select: function (e) { "function" != typeof e && (e = C(e)); for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r)for (var i, a, l = t[r], s = l.length, u = o[r] = Array(s), c = 0; c < s; ++c)(i = l[c]) && (a = e.call(i, i.__data__, c, l)) && ("__data__" in i && (a.__data__ = i.__data__), u[c] = a); return new ed(o, this._parents) }, selectAll: function (e) { if ("function" == typeof e) { var t; t = e, e = function () { var e; return e = t.apply(this, arguments), null == e ? [] : Array.isArray(e) ? e : Array.from(e) } } else e = A(e); for (var n = this._groups, o = n.length, r = [], i = [], a = 0; a < o; ++a)for (var l, s = n[a], u = s.length, c = 0; c < u; ++c)(l = s[c]) && (r.push(e.call(l, l.__data__, c, s)), i.push(l)); return new ed(r, i) }, selectChild: function (e) { var t; return this.select(null == e ? $ : (t = "function" == typeof e ? e : P(e), function () { return z.call(this.children, t) })) }, selectChildren: function (e) { var t; return this.selectAll(null == e ? I : (t = "function" == typeof e ? e : P(e), function () { return D.call(this.children, t) })) }, filter: function (e) { "function" != typeof e && (e = j(e)); for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r)for (var i, a = t[r], l = a.length, s = o[r] = [], u = 0; u < l; ++u)(i = a[u]) && e.call(i, i.__data__, u, a) && s.push(i); return new ed(o, this._parents) }, data: function (e, t) { if (!arguments.length) return Array.from(this, B); var n = t ? O : L, o = this._parents, r = this._groups; "function" != typeof e && (x = e, e = function () { return x }); for (var i = r.length, a = Array(i), l = Array(i), s = Array(i), u = 0; u < i; ++u) { var c = o[u], d = r[u], h = d.length, f = "object" == typeof (y = e.call(c, c && c.__data__, u, o)) && "length" in y ? y : Array.from(y), p = f.length, g = l[u] = Array(p), m = a[u] = Array(p); n(c, d, g, m, s[u] = Array(h), f, t); for (var y, x, v, b, w = 0, S = 0; w < p; ++w)if (v = g[w]) { for (w >= S && (S = w + 1); !(b = m[S]) && ++S < p;); v._next = b || null } } return (a = new ed(a, o))._enter = l, a._exit = s, a }, enter: function () { return new ed(this._enter || this._groups.map(T), this._parents) }, exit: function () { return new ed(this._exit || this._groups.map(T), this._parents) }, join: function (e, t, n) { var o = this.enter(), r = this, i = this.exit(); return "function" == typeof e ? (o = e(o)) && (o = o.selection()) : o = o.append(e + ""), null != t && (r = t(r)) && (r = r.selection()), null == n ? i.remove() : n(i), o && r ? o.merge(r).order() : r }, merge: function (e) { for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, r = n.length, i = o.length, a = Math.min(r, i), l = Array(r), s = 0; s < a; ++s)for (var u, c = n[s], d = o[s], h = c.length, f = l[s] = Array(h), p = 0; p < h; ++p)(u = c[p] || d[p]) && (f[p] = u); for (; s < r; ++s)l[s] = n[s]; return new ed(l, this._parents) }, selection: function () { return this }, order: function () { for (var e = this._groups, t = -1, n = e.length; ++t < n;)for (var o, r = e[t], i = r.length - 1, a = r[i]; --i >= 0;)(o = r[i]) && (a && 4 ^ o.compareDocumentPosition(a) && a.parentNode.insertBefore(o, a), a = o); return this }, sort: function (e) { function t(t, n) { return t && n ? e(t.__data__, n.__data__) : !t - !n } e || (e = V); for (var n = this._groups, o = n.length, r = Array(o), i = 0; i < o; ++i) { for (var a, l = n[i], s = l.length, u = r[i] = Array(s), c = 0; c < s; ++c)(a = l[c]) && (u[c] = a); u.sort(t) } return new ed(r, this._parents).order() }, call: function () { var e = arguments[0]; return arguments[0] = this, e.apply(null, arguments), this }, nodes: function () { return Array.from(this) }, node: function () { for (var e = this._groups, t = 0, n = e.length; t < n; ++t)for (var o = e[t], r = 0, i = o.length; r < i; ++r) { var a = o[r]; if (a) return a } return null }, size: function () { let e = 0; for (let t of this) ++e; return e }, empty: function () { return !this.node() }, each: function (e) { for (var t = this._groups, n = 0, o = t.length; n < o; ++n)for (var r, i = t[n], a = 0, l = i.length; a < l; ++a)(r = i[a]) && e.call(r, r.__data__, a, i); return this }, attr: function (e, t) { var n = X(e); if (arguments.length < 2) { var o = this.node(); return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n) } return this.each((null == t ? n.local ? function (e) { return function () { this.removeAttributeNS(e.space, e.local) } } : function (e) { return function () { this.removeAttribute(e) } } : "function" == typeof t ? n.local ? function (e, t) { return function () { var n = t.apply(this, arguments); null == n ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n) } } : function (e, t) { return function () { var n = t.apply(this, arguments); null == n ? this.removeAttribute(e) : this.setAttribute(e, n) } } : n.local ? function (e, t) { return function () { this.setAttributeNS(e.space, e.local, t) } } : function (e, t) { return function () { this.setAttribute(e, t) } })(n, t)) }, style: function (e, t, n) { return arguments.length > 1 ? this.each((null == t ? function (e) { return function () { this.style.removeProperty(e) } } : "function" == typeof t ? function (e, t, n) { return function () { var o = t.apply(this, arguments); null == o ? this.style.removeProperty(e) : this.style.setProperty(e, o, n) } } : function (e, t, n) { return function () { this.style.setProperty(e, t, n) } })(e, t, null == n ? "" : n)) : Z(this.node(), e) }, property: function (e, t) { return arguments.length > 1 ? this.each((null == t ? function (e) { return function () { delete this[e] } } : "function" == typeof t ? function (e, t) { return function () { var n = t.apply(this, arguments); null == n ? delete this[e] : this[e] = n } } : function (e, t) { return function () { this[e] = t } })(e, t)) : this.node()[e] }, classed: function (e, t) { var n = K(e + ""); if (arguments.length < 2) { for (var o = q(this.node()), r = -1, i = n.length; ++r < i;)if (!o.contains(n[r])) return !1; return !0 } return this.each(("function" == typeof t ? function (e, t) { return function () { (t.apply(this, arguments) ? U : G)(this, e) } } : t ? function (e) { return function () { U(this, e) } } : function (e) { return function () { G(this, e) } })(n, t)) }, text: function (e) { return arguments.length ? this.each(null == e ? Q : ("function" == typeof e ? function (e) { return function () { var t = e.apply(this, arguments); this.textContent = null == t ? "" : t } } : function (e) { return function () { this.textContent = e } })(e)) : this.node().textContent }, html: function (e) { return arguments.length ? this.each(null == e ? J : ("function" == typeof e ? function (e) { return function () { var t = e.apply(this, arguments); this.innerHTML = null == t ? "" : t } } : function (e) { return function () { this.innerHTML = e } })(e)) : this.node().innerHTML }, raise: function () { return this.each(ee) }, lower: function () { return this.each(et) }, append: function (e) { var t = "function" == typeof e ? e : en(e); return this.select(function () { return this.appendChild(t.apply(this, arguments)) }) }, insert: function (e, t) { var n = "function" == typeof e ? e : en(e), o = null == t ? eo : "function" == typeof t ? t : C(t); return this.select(function () { return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null) }) }, remove: function () { return this.each(er) }, clone: function (e) { return this.select(e ? ea : ei) }, datum: function (e) { return arguments.length ? this.property("__data__", e) : this.node().__data__ }, on: function (e, t, n) { var o, r, i = (e + "").trim().split(/^|\s+/).map(function (e) { var t = "", n = e.indexOf("."); return n >= 0 && (t = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: t } }), a = i.length; if (arguments.length < 2) { var l = this.node().__on; if (l) { for (var s, u = 0, c = l.length; u < c; ++u)for (o = 0, s = l[u]; o < a; ++o)if ((r = i[o]).type === s.type && r.name === s.name) return s.value } return } for (o = 0, l = t ? es : el; o < a; ++o)this.each(l(i[o], t, n)); return this }, dispatch: function (e, t) { return this.each(("function" == typeof t ? function (e, t) { return function () { return eu(this, e, t.apply(this, arguments)) } } : function (e, t) { return function () { return eu(this, e, t) } })(e, t)) }, [Symbol.iterator]: function* () { for (var e = this._groups, t = 0, n = e.length; t < n; ++t)for (var o, r = e[t], i = 0, a = r.length; i < a; ++i)(o = r[i]) && (yield o) } }; let eg = { passive: !1 }, em = { capture: !0, passive: !1 }; function ey(e) { e.stopImmediatePropagation() } function ex(e) { e.preventDefault(), e.stopImmediatePropagation() } function ev(e) { var t = e.document.documentElement, n = ef(e).on("dragstart.drag", ex, em); "onselectstart" in t ? n.on("selectstart.drag", ex, em) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none") } function eb(e, t) { var n = e.document.documentElement, o = ef(e).on("dragstart.drag", null); t && (o.on("click.drag", ex, em), setTimeout(function () { o.on("click.drag", null) }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect) } let ew = e => () => e; function eS(e, { sourceEvent: t, subject: n, target: o, identifier: r, active: i, x: a, y: l, dx: s, dy: u, dispatch: c }) { Object.defineProperties(this, { type: { value: e, enumerable: !0, configurable: !0 }, sourceEvent: { value: t, enumerable: !0, configurable: !0 }, subject: { value: n, enumerable: !0, configurable: !0 }, target: { value: o, enumerable: !0, configurable: !0 }, identifier: { value: r, enumerable: !0, configurable: !0 }, active: { value: i, enumerable: !0, configurable: !0 }, x: { value: a, enumerable: !0, configurable: !0 }, y: { value: l, enumerable: !0, configurable: !0 }, dx: { value: s, enumerable: !0, configurable: !0 }, dy: { value: u, enumerable: !0, configurable: !0 }, _: { value: c } }) } function e_(e) { return !e.ctrlKey && !e.button } function eM() { return this.parentNode } function eE(e, t) { return null == t ? { x: e.x, y: e.y } : t } function ek() { return navigator.maxTouchPoints || "ontouchstart" in this } function eC() { var e, t, n, o, r = e_, i = eM, a = eE, l = ek, s = {}, u = _("start", "drag", "end"), c = 0, d = 0; function h(e) { e.on("mousedown.drag", f).filter(l).on("touchstart.drag", m).on("touchmove.drag", y, eg).on("touchend.drag touchcancel.drag", x).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function f(a, l) { if (!o && r.call(this, a, l)) { var s = v(this, i.call(this, a, l), a, l, "mouse"); s && (ef(a.view).on("mousemove.drag", p, em).on("mouseup.drag", g, em), ev(a.view), ey(a), n = !1, e = a.clientX, t = a.clientY, s("start", a)) } } function p(o) { if (ex(o), !n) { var r = o.clientX - e, i = o.clientY - t; n = r * r + i * i > d } s.mouse("drag", o) } function g(e) { ef(e.view).on("mousemove.drag mouseup.drag", null), eb(e.view, n), ex(e), s.mouse("end", e) } function m(e, t) { if (r.call(this, e, t)) { var n, o, a = e.changedTouches, l = i.call(this, e, t), s = a.length; for (n = 0; n < s; ++n)(o = v(this, l, e, t, a[n].identifier, a[n])) && (ey(e), o("start", e, a[n])) } } function y(e) { var t, n, o = e.changedTouches, r = o.length; for (t = 0; t < r; ++t)(n = s[o[t].identifier]) && (ex(e), n("drag", e, o[t])) } function x(e) { var t, n, r = e.changedTouches, i = r.length; for (o && clearTimeout(o), o = setTimeout(function () { o = null }, 500), t = 0; t < i; ++t)(n = s[r[t].identifier]) && (ey(e), n("end", e, r[t])) } function v(e, t, n, o, r, i) { var l, d, f, p = u.copy(), g = ep(i || n, t); if (null != (f = a.call(e, new eS("beforestart", { sourceEvent: n, target: h, identifier: r, active: c, x: g[0], y: g[1], dx: 0, dy: 0, dispatch: p }), o))) return l = f.x - g[0] || 0, d = f.y - g[1] || 0, function n(i, a, u) { var m, y = g; switch (i) { case "start": s[r] = n, m = c++; break; case "end": delete s[r], --c; case "drag": g = ep(u || a, t), m = c }p.call(i, e, new eS(i, { sourceEvent: a, subject: f, target: h, identifier: r, active: m, x: g[0] + l, y: g[1] + d, dx: g[0] - y[0], dy: g[1] - y[1], dispatch: p }), o) } } return h.filter = function (e) { return arguments.length ? (r = "function" == typeof e ? e : ew(!!e), h) : r }, h.container = function (e) { return arguments.length ? (i = "function" == typeof e ? e : ew(e), h) : i }, h.subject = function (e) { return arguments.length ? (a = "function" == typeof e ? e : ew(e), h) : a }, h.touchable = function (e) { return arguments.length ? (l = "function" == typeof e ? e : ew(!!e), h) : l }, h.on = function () { var e = u.on.apply(u, arguments); return e === u ? h : e }, h.clickDistance = function (e) { return arguments.length ? (d = (e *= 1) * e, h) : Math.sqrt(d) }, h } function eN(e) { return ((e = Math.exp(e)) + 1 / e) / 2 } eS.prototype.on = function () { var e = this._.on.apply(this._, arguments); return e === this._ ? this : e }; let eA = function e(t, n, o) { function r(e, r) { var i, a, l = e[0], s = e[1], u = e[2], c = r[0], d = r[1], h = r[2], f = c - l, p = d - s, g = f * f + p * p; if (g < 1e-12) a = Math.log(h / u) / t, i = function (e) { return [l + e * f, s + e * p, u * Math.exp(t * e * a)] }; else { var m = Math.sqrt(g), y = (h * h - u * u + o * g) / (2 * u * n * m), x = (h * h - u * u - o * g) / (2 * h * n * m), v = Math.log(Math.sqrt(y * y + 1) - y); a = (Math.log(Math.sqrt(x * x + 1) - x) - v) / t, i = function (e) { var o, r, i = e * a, c = eN(v), d = u / (n * m) * (c * (((o = Math.exp(2 * (o = t * i + v))) - 1) / (o + 1)) - ((r = Math.exp(r = v)) - 1 / r) / 2); return [l + d * f, s + d * p, u * c / eN(t * i + v)] } } return i.duration = 1e3 * a * t / Math.SQRT2, i } return r.rho = function (t) { var n = Math.max(.001, +t), o = n * n; return e(n, o, o * o) }, r }(Math.SQRT2, 2, 4); var ej, eP, ez = 0, e$ = 0, eD = 0, eI = 0, eT = 0, eR = 0, eL = "object" == typeof performance && performance.now ? performance : Date, eO = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (e) { setTimeout(e, 17) }; function eB() { return eT || (eO(eV), eT = eL.now() + eR) } function eV() { eT = 0 } function eH() { this._call = this._time = this._next = null } function eF(e, t, n) { var o = new eH; return o.restart(e, t, n), o } function eX() { eT = (eI = eL.now()) + eR, ez = e$ = 0; try { eB(), ++ez; for (var e, t = ej; t;)(e = eT - t._time) >= 0 && t._call.call(void 0, e), t = t._next; --ez } finally { ez = 0, function () { for (var e, t, n = ej, o = 1 / 0; n;)n._call ? (o > n._time && (o = n._time), e = n, n = n._next) : (t = n._next, n._next = null, n = e ? e._next = t : ej = t); eP = e, eZ(o) }(), eT = 0 } } function eY() { var e = eL.now(), t = e - eI; t > 1e3 && (eR -= t, eI = e) } function eZ(e) { !ez && (e$ && (e$ = clearTimeout(e$)), e - eT > 24 ? (e < 1 / 0 && (e$ = setTimeout(eX, e - eL.now() - eR)), eD && (eD = clearInterval(eD))) : (eD || (eI = eL.now(), eD = setInterval(eY, 1e3)), ez = 1, eO(eX))) } function eK(e, t, n) { var o = new eH; return t = null == t ? 0 : +t, o.restart(n => { o.stop(), e(n + t) }, t, n), o } eH.prototype = eF.prototype = { constructor: eH, restart: function (e, t, n) { if ("function" != typeof e) throw TypeError("callback is not a function"); n = (null == n ? eB() : +n) + (null == t ? 0 : +t), this._next || eP === this || (eP ? eP._next = this : ej = this, eP = this), this._call = e, this._time = n, eZ() }, stop: function () { this._call && (this._call = null, this._time = 1 / 0, eZ()) } }; var eq = _("start", "end", "cancel", "interrupt"), eW = []; function eU(e, t, n, o, r, i) { var a = e.__transition; if (a) { if (n in a) return } else e.__transition = {}; !function (e, t, n) { var o, r = e.__transition; function i(s) { var u, c, d, h; if (1 !== n.state) return l(); for (u in r) if ((h = r[u]).name === n.name) { if (3 === h.state) return eK(i); 4 === h.state ? (h.state = 6, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete r[u]) : +u < t && (h.state = 6, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete r[u]) } if (eK(function () { 3 === n.state && (n.state = 4, n.timer.restart(a, n.delay, n.time), a(s)) }), n.state = 2, n.on.call("start", e, e.__data__, n.index, n.group), 2 === n.state) { for (u = 0, n.state = 3, o = Array(d = n.tween.length), c = -1; u < d; ++u)(h = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (o[++c] = h); o.length = c + 1 } } function a(t) { for (var r = t < n.duration ? n.ease.call(null, t / n.duration) : (n.timer.restart(l), n.state = 5, 1), i = -1, a = o.length; ++i < a;)o[i].call(e, r); 5 === n.state && (n.on.call("end", e, e.__data__, n.index, n.group), l()) } function l() { for (var o in n.state = 6, n.timer.stop(), delete r[t], r) return; delete e.__transition } r[t] = n, n.timer = eF(function (e) { n.state = 1, n.timer.restart(i, n.delay, n.time), n.delay <= e && i(e - n.delay) }, 0, n.time) }(e, n, { name: t, index: o, group: r, on: eq, tween: eW, time: i.time, delay: i.delay, duration: i.duration, ease: i.ease, timer: null, state: 0 }) } function eG(e, t) { var n = eJ(e, t); if (n.state > 0) throw Error("too late; already scheduled"); return n } function eQ(e, t) { var n = eJ(e, t); if (n.state > 3) throw Error("too late; already running"); return n } function eJ(e, t) { var n = e.__transition; if (!n || !(n = n[t])) throw Error("transition not found"); return n } function e0(e, t) { var n, o, r, i = e.__transition, a = !0; if (i) { for (r in t = null == t ? null : t + "", i) { if ((n = i[r]).name !== t) { a = !1; continue } o = n.state > 2 && n.state < 5, n.state = 6, n.timer.stop(), n.on.call(o ? "interrupt" : "cancel", e, e.__data__, n.index, n.group), delete i[r] } a && delete e.__transition } } function e1(e, t) { return e *= 1, t *= 1, function (n) { return e * (1 - n) + t * n } } var e2 = 180 / Math.PI, e5 = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }; function e3(e, t, n, o, r, i) { var a, l, s; return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (s = e * n + t * o) && (n -= e * s, o -= t * s), (l = Math.sqrt(n * n + o * o)) && (n /= l, o /= l, s /= l), e * o < t * n && (e = -e, t = -t, s = -s, a = -a), { translateX: r, translateY: i, rotate: Math.atan2(t, e) * e2, skewX: Math.atan(s) * e2, scaleX: a, scaleY: l } } function e4(e, t, n, o) { function r(e) { return e.length ? e.pop() + " " : "" } return function (i, a) { var l, s, u, c, d = [], h = []; return i = e(i), a = e(a), !function (e, o, r, i, a, l) { if (e !== r || o !== i) { var s = a.push("translate(", null, t, null, n); l.push({ i: s - 4, x: e1(e, r) }, { i: s - 2, x: e1(o, i) }) } else (r || i) && a.push("translate(" + r + t + i + n) }(i.translateX, i.translateY, a.translateX, a.translateY, d, h), l = i.rotate, s = a.rotate, l !== s ? (l - s > 180 ? s += 360 : s - l > 180 && (l += 360), h.push({ i: d.push(r(d) + "rotate(", null, o) - 2, x: e1(l, s) })) : s && d.push(r(d) + "rotate(" + s + o), u = i.skewX, c = a.skewX, u !== c ? h.push({ i: d.push(r(d) + "skewX(", null, o) - 2, x: e1(u, c) }) : c && d.push(r(d) + "skewX(" + c + o), !function (e, t, n, o, i, a) { if (e !== n || t !== o) { var l = i.push(r(i) + "scale(", null, ",", null, ")"); a.push({ i: l - 4, x: e1(e, n) }, { i: l - 2, x: e1(t, o) }) } else (1 !== n || 1 !== o) && i.push(r(i) + "scale(" + n + "," + o + ")") }(i.scaleX, i.scaleY, a.scaleX, a.scaleY, d, h), i = a = null, function (e) { for (var t, n = -1, o = h.length; ++n < o;)d[(t = h[n]).i] = t.x(e); return d.join("") } } } var e6 = e4(function (e) { let t = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(e + ""); return t.isIdentity ? e5 : e3(t.a, t.b, t.c, t.d, t.e, t.f) }, "px, ", "px)", "deg)"), e8 = e4(function (e) { return null == e ? e5 : (u || (u = document.createElementNS("http://www.w3.org/2000/svg", "g")), u.setAttribute("transform", e), e = u.transform.baseVal.consolidate()) ? e3((e = e.matrix).a, e.b, e.c, e.d, e.e, e.f) : e5 }, ", ", ")", ")"); function e9(e, t, n) { var o = e._id; return e.each(function () { var e = eQ(this, o); (e.value || (e.value = {}))[t] = n.apply(this, arguments) }), function (e) { return eJ(e, o).value[t] } } function e7(e, t, n) { e.prototype = t.prototype = n, n.constructor = e } function te(e, t) { var n = Object.create(e.prototype); for (var o in t) n[o] = t[o]; return n } function tt() { } var tn = "\\s*([+-]?\\d+)\\s*", to = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", tr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", ti = /^#([0-9a-f]{3,8})$/, ta = RegExp(`^rgb\\(${tn},${tn},${tn}\\)$`), tl = RegExp(`^rgb\\(${tr},${tr},${tr}\\)$`), ts = RegExp(`^rgba\\(${tn},${tn},${tn},${to}\\)$`), tu = RegExp(`^rgba\\(${tr},${tr},${tr},${to}\\)$`), tc = RegExp(`^hsl\\(${to},${tr},${tr}\\)$`), td = RegExp(`^hsla\\(${to},${tr},${tr},${to}\\)$`), th = { aliceblue: 0xf0f8ff, antiquewhite: 0xfaebd7, aqua: 65535, aquamarine: 8388564, azure: 0xf0ffff, beige: 0xf5f5dc, bisque: 0xffe4c4, black: 0, blanchedalmond: 0xffebcd, blue: 255, blueviolet: 9055202, brown: 0xa52a2a, burlywood: 0xdeb887, cadetblue: 6266528, chartreuse: 8388352, chocolate: 0xd2691e, coral: 0xff7f50, cornflowerblue: 6591981, cornsilk: 0xfff8dc, crimson: 0xdc143c, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 0xb8860b, darkgray: 0xa9a9a9, darkgreen: 25600, darkgrey: 0xa9a9a9, darkkhaki: 0xbdb76b, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 0xff8c00, darkorchid: 0x9932cc, darkred: 9109504, darksalmon: 0xe9967a, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 0xff1493, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 0xb22222, floralwhite: 0xfffaf0, forestgreen: 2263842, fuchsia: 0xff00ff, gainsboro: 0xdcdcdc, ghostwhite: 0xf8f8ff, gold: 0xffd700, goldenrod: 0xdaa520, gray: 8421504, green: 32768, greenyellow: 0xadff2f, grey: 8421504, honeydew: 0xf0fff0, hotpink: 0xff69b4, indianred: 0xcd5c5c, indigo: 4915330, ivory: 0xfffff0, khaki: 0xf0e68c, lavender: 0xe6e6fa, lavenderblush: 0xfff0f5, lawngreen: 8190976, lemonchiffon: 0xfffacd, lightblue: 0xadd8e6, lightcoral: 0xf08080, lightcyan: 0xe0ffff, lightgoldenrodyellow: 0xfafad2, lightgray: 0xd3d3d3, lightgreen: 9498256, lightgrey: 0xd3d3d3, lightpink: 0xffb6c1, lightsalmon: 0xffa07a, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 0xb0c4de, lightyellow: 0xffffe0, lime: 65280, limegreen: 3329330, linen: 0xfaf0e6, magenta: 0xff00ff, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 0xba55d3, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 0xc71585, midnightblue: 1644912, mintcream: 0xf5fffa, mistyrose: 0xffe4e1, moccasin: 0xffe4b5, navajowhite: 0xffdead, navy: 128, oldlace: 0xfdf5e6, olive: 8421376, olivedrab: 7048739, orange: 0xffa500, orangered: 0xff4500, orchid: 0xda70d6, palegoldenrod: 0xeee8aa, palegreen: 0x98fb98, paleturquoise: 0xafeeee, palevioletred: 0xdb7093, papayawhip: 0xffefd5, peachpuff: 0xffdab9, peru: 0xcd853f, pink: 0xffc0cb, plum: 0xdda0dd, powderblue: 0xb0e0e6, purple: 8388736, rebeccapurple: 6697881, red: 0xff0000, rosybrown: 0xbc8f8f, royalblue: 4286945, saddlebrown: 9127187, salmon: 0xfa8072, sandybrown: 0xf4a460, seagreen: 3050327, seashell: 0xfff5ee, sienna: 0xa0522d, silver: 0xc0c0c0, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 0xfffafa, springgreen: 65407, steelblue: 4620980, tan: 0xd2b48c, teal: 32896, thistle: 0xd8bfd8, tomato: 0xff6347, turquoise: 4251856, violet: 0xee82ee, wheat: 0xf5deb3, white: 0xffffff, whitesmoke: 0xf5f5f5, yellow: 0xffff00, yellowgreen: 0x9acd32 }; function tf() { return this.rgb().formatHex() } function tp() { return this.rgb().formatRgb() } function tg(e) { var t, n; return e = (e + "").trim().toLowerCase(), (t = ti.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), 6 === n ? tm(t) : 3 === n ? new tv(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, (15 & t) << 4 | 15 & t, 1) : 8 === n ? ty(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (255 & t) / 255) : 4 === n ? ty(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, ((15 & t) << 4 | 15 & t) / 255) : null) : (t = ta.exec(e)) ? new tv(t[1], t[2], t[3], 1) : (t = tl.exec(e)) ? new tv(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, 1) : (t = ts.exec(e)) ? ty(t[1], t[2], t[3], t[4]) : (t = tu.exec(e)) ? ty(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, t[4]) : (t = tc.exec(e)) ? tE(t[1], t[2] / 100, t[3] / 100, 1) : (t = td.exec(e)) ? tE(t[1], t[2] / 100, t[3] / 100, t[4]) : th.hasOwnProperty(e) ? tm(th[e]) : "transparent" === e ? new tv(NaN, NaN, NaN, 0) : null } function tm(e) { return new tv(e >> 16 & 255, e >> 8 & 255, 255 & e, 1) } function ty(e, t, n, o) { return o <= 0 && (e = t = n = NaN), new tv(e, t, n, o) } function tx(e, t, n, o) { var r; return 1 == arguments.length ? ((r = e) instanceof tt || (r = tg(r)), r) ? new tv((r = r.rgb()).r, r.g, r.b, r.opacity) : new tv : new tv(e, t, n, null == o ? 1 : o) } function tv(e, t, n, o) { this.r = +e, this.g = +t, this.b = +n, this.opacity = +o } function tb() { return `#${tM(this.r)}${tM(this.g)}${tM(this.b)}` } function tw() { let e = tS(this.opacity); return `${1 === e ? "rgb(" : "rgba("}${t_(this.r)}, ${t_(this.g)}, ${t_(this.b)}${1 === e ? ")" : `, ${e})`}` } function tS(e) { return isNaN(e) ? 1 : Math.max(0, Math.min(1, e)) } function t_(e) { return Math.max(0, Math.min(255, Math.round(e) || 0)) } function tM(e) { return ((e = t_(e)) < 16 ? "0" : "") + e.toString(16) } function tE(e, t, n, o) { return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new tC(e, t, n, o) } function tk(e) { if (e instanceof tC) return new tC(e.h, e.s, e.l, e.opacity); if (e instanceof tt || (e = tg(e)), !e) return new tC; if (e instanceof tC) return e; var t = (e = e.rgb()).r / 255, n = e.g / 255, o = e.b / 255, r = Math.min(t, n, o), i = Math.max(t, n, o), a = NaN, l = i - r, s = (i + r) / 2; return l ? (a = t === i ? (n - o) / l + (n < o) * 6 : n === i ? (o - t) / l + 2 : (t - n) / l + 4, l /= s < .5 ? i + r : 2 - i - r, a *= 60) : l = s > 0 && s < 1 ? 0 : a, new tC(a, l, s, e.opacity) } function tC(e, t, n, o) { this.h = +e, this.s = +t, this.l = +n, this.opacity = +o } function tN(e) { return (e = (e || 0) % 360) < 0 ? e + 360 : e } function tA(e) { return Math.max(0, Math.min(1, e || 0)) } function tj(e, t, n) { return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255 } function tP(e, t, n, o, r) { var i = e * e, a = i * e; return ((1 - 3 * e + 3 * i - a) * t + (4 - 6 * i + 3 * a) * n + (1 + 3 * e + 3 * i - 3 * a) * o + a * r) / 6 } e7(tt, tg, { copy(e) { return Object.assign(new this.constructor, this, e) }, displayable() { return this.rgb().displayable() }, hex: tf, formatHex: tf, formatHex8: function () { return this.rgb().formatHex8() }, formatHsl: function () { return tk(this).formatHsl() }, formatRgb: tp, toString: tp }), e7(tv, tx, te(tt, { brighter(e) { return e = null == e ? 1.4285714285714286 : Math.pow(1.4285714285714286, e), new tv(this.r * e, this.g * e, this.b * e, this.opacity) }, darker(e) { return e = null == e ? .7 : Math.pow(.7, e), new tv(this.r * e, this.g * e, this.b * e, this.opacity) }, rgb() { return this }, clamp() { return new tv(t_(this.r), t_(this.g), t_(this.b), tS(this.opacity)) }, displayable() { return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1 }, hex: tb, formatHex: tb, formatHex8: function () { return `#${tM(this.r)}${tM(this.g)}${tM(this.b)}${tM((isNaN(this.opacity) ? 1 : this.opacity) * 255)}` }, formatRgb: tw, toString: tw })), e7(tC, function (e, t, n, o) { return 1 == arguments.length ? tk(e) : new tC(e, t, n, null == o ? 1 : o) }, te(tt, { brighter(e) { return e = null == e ? 1.4285714285714286 : Math.pow(1.4285714285714286, e), new tC(this.h, this.s, this.l * e, this.opacity) }, darker(e) { return e = null == e ? .7 : Math.pow(.7, e), new tC(this.h, this.s, this.l * e, this.opacity) }, rgb() { var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < .5 ? n : 1 - n) * t, r = 2 * n - o; return new tv(tj(e >= 240 ? e - 240 : e + 120, r, o), tj(e, r, o), tj(e < 120 ? e + 240 : e - 120, r, o), this.opacity) }, clamp() { return new tC(tN(this.h), tA(this.s), tA(this.l), tS(this.opacity)) }, displayable() { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 }, formatHsl() { let e = tS(this.opacity); return `${1 === e ? "hsl(" : "hsla("}${tN(this.h)}, ${100 * tA(this.s)}%, ${100 * tA(this.l)}%${1 === e ? ")" : `, ${e})`}` } })); let tz = e => () => e; function t$(e, t) { var n = t - e; return n ? function (t) { return e + t * n } : tz(isNaN(e) ? t : e) } let tD = function e(t) { var n, o = 1 == (n = +t) ? t$ : function (e, t) { var o, r, i; return t - e ? (o = e, r = t, o = Math.pow(o, i = n), r = Math.pow(r, i) - o, i = 1 / i, function (e) { return Math.pow(o + e * r, i) }) : tz(isNaN(e) ? t : e) }; function r(e, t) { var n = o((e = tx(e)).r, (t = tx(t)).r), r = o(e.g, t.g), i = o(e.b, t.b), a = t$(e.opacity, t.opacity); return function (t) { return e.r = n(t), e.g = r(t), e.b = i(t), e.opacity = a(t), e + "" } } return r.gamma = e, r }(1); function tI(e) { return function (t) { var n, o, r = t.length, i = Array(r), a = Array(r), l = Array(r); for (n = 0; n < r; ++n)o = tx(t[n]), i[n] = o.r || 0, a[n] = o.g || 0, l[n] = o.b || 0; return i = e(i), a = e(a), l = e(l), o.opacity = 1, function (e) { return o.r = i(e), o.g = a(e), o.b = l(e), o + "" } } } tI(function (e) { var t = e.length - 1; return function (n) { var o = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), r = e[o], i = e[o + 1], a = o > 0 ? e[o - 1] : 2 * r - i, l = o < t - 1 ? e[o + 2] : 2 * i - r; return tP((n - o / t) * t, a, r, i, l) } }), tI(function (e) { var t = e.length; return function (n) { var o = Math.floor(((n %= 1) < 0 ? ++n : n) * t), r = e[(o + t - 1) % t], i = e[o % t], a = e[(o + 1) % t], l = e[(o + 2) % t]; return tP((n - o / t) * t, r, i, a, l) } }); var tT = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, tR = RegExp(tT.source, "g"); function tL(e, t) { var n, o, r, i, a, l = tT.lastIndex = tR.lastIndex = 0, s = -1, u = [], c = []; for (e += "", t += ""; (r = tT.exec(e)) && (i = tR.exec(t));)(a = i.index) > l && (a = t.slice(l, a), u[s] ? u[s] += a : u[++s] = a), (r = r[0]) === (i = i[0]) ? u[s] ? u[s] += i : u[++s] = i : (u[++s] = null, c.push({ i: s, x: e1(r, i) })), l = tR.lastIndex; return l < t.length && (a = t.slice(l), u[s] ? u[s] += a : u[++s] = a), u.length < 2 ? c[0] ? (n = c[0].x, function (e) { return n(e) + "" }) : (o = t, function () { return o }) : (t = c.length, function (e) { for (var n, o = 0; o < t; ++o)u[(n = c[o]).i] = n.x(e); return u.join("") }) } function tO(e, t) { var n; return ("number" == typeof t ? e1 : t instanceof tg ? tD : (n = tg(t)) ? (t = n, tD) : tL)(e, t) } var tB = eh.prototype.constructor; function tV(e) { return function () { this.style.removeProperty(e) } } var tH = 0; function tF(e, t, n, o) { this._groups = e, this._parents = t, this._name = n, this._id = o } var tX = eh.prototype; tF.prototype = (function (e) { return eh().transition(e) }).prototype = { constructor: tF, select: function (e) { var t = this._name, n = this._id; "function" != typeof e && (e = C(e)); for (var o = this._groups, r = o.length, i = Array(r), a = 0; a < r; ++a)for (var l, s, u = o[a], c = u.length, d = i[a] = Array(c), h = 0; h < c; ++h)(l = u[h]) && (s = e.call(l, l.__data__, h, u)) && ("__data__" in l && (s.__data__ = l.__data__), d[h] = s, eU(d[h], t, n, h, d, eJ(l, n))); return new tF(i, this._parents, t, n) }, selectAll: function (e) { var t = this._name, n = this._id; "function" != typeof e && (e = A(e)); for (var o = this._groups, r = o.length, i = [], a = [], l = 0; l < r; ++l)for (var s, u = o[l], c = u.length, d = 0; d < c; ++d)if (s = u[d]) { for (var h, f = e.call(s, s.__data__, d, u), p = eJ(s, n), g = 0, m = f.length; g < m; ++g)(h = f[g]) && eU(h, t, n, g, f, p); i.push(f), a.push(s) } return new tF(i, a, t, n) }, selectChild: tX.selectChild, selectChildren: tX.selectChildren, filter: function (e) { "function" != typeof e && (e = j(e)); for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r)for (var i, a = t[r], l = a.length, s = o[r] = [], u = 0; u < l; ++u)(i = a[u]) && e.call(i, i.__data__, u, a) && s.push(i); return new tF(o, this._parents, this._name, this._id) }, merge: function (e) { if (e._id !== this._id) throw Error(); for (var t = this._groups, n = e._groups, o = t.length, r = n.length, i = Math.min(o, r), a = Array(o), l = 0; l < i; ++l)for (var s, u = t[l], c = n[l], d = u.length, h = a[l] = Array(d), f = 0; f < d; ++f)(s = u[f] || c[f]) && (h[f] = s); for (; l < o; ++l)a[l] = t[l]; return new tF(a, this._parents, this._name, this._id) }, selection: function () { return new tB(this._groups, this._parents) }, transition: function () { for (var e = this._name, t = this._id, n = ++tH, o = this._groups, r = o.length, i = 0; i < r; ++i)for (var a, l = o[i], s = l.length, u = 0; u < s; ++u)if (a = l[u]) { var c = eJ(a, t); eU(a, e, n, u, l, { time: c.time + c.delay + c.duration, delay: 0, duration: c.duration, ease: c.ease }) } return new tF(o, this._parents, e, n) }, call: tX.call, nodes: tX.nodes, node: tX.node, size: tX.size, empty: tX.empty, each: tX.each, on: function (e, t) { var n, o, r, i, a, l, s = this._id; return arguments.length < 2 ? eJ(this.node(), s).on.on(e) : this.each((n = s, o = e, r = t, l = (o + "").trim().split(/^|\s+/).every(function (e) { var t = e.indexOf("."); return t >= 0 && (e = e.slice(0, t)), !e || "start" === e }) ? eG : eQ, function () { var e = l(this, n), t = e.on; t !== i && (a = (i = t).copy()).on(o, r), e.on = a })) }, attr: function (e, t) { var n = X(e), o = "transform" === n ? e8 : tO; return this.attrTween(e, "function" == typeof t ? (n.local ? function (e, t, n) { var o, r, i; return function () { var a, l, s = n(this); return null == s ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local)) === (l = s + "") ? null : a === o && l === r ? i : (r = l, i = t(o = a, s)) } } : function (e, t, n) { var o, r, i; return function () { var a, l, s = n(this); return null == s ? void this.removeAttribute(e) : (a = this.getAttribute(e)) === (l = s + "") ? null : a === o && l === r ? i : (r = l, i = t(o = a, s)) } })(n, o, e9(this, "attr." + e, t)) : null == t ? (n.local ? function (e) { return function () { this.removeAttributeNS(e.space, e.local) } } : function (e) { return function () { this.removeAttribute(e) } })(n) : (n.local ? function (e, t, n) { var o, r, i = n + ""; return function () { var a = this.getAttributeNS(e.space, e.local); return a === i ? null : a === o ? r : r = t(o = a, n) } } : function (e, t, n) { var o, r, i = n + ""; return function () { var a = this.getAttribute(e); return a === i ? null : a === o ? r : r = t(o = a, n) } })(n, o, t)) }, attrTween: function (e, t) { var n = "attr." + e; if (arguments.length < 2) return (n = this.tween(n)) && n._value; if (null == t) return this.tween(n, null); if ("function" != typeof t) throw Error(); var o = X(e); return this.tween(n, (o.local ? function (e, t) { var n, o; function r() { var r = t.apply(this, arguments); return r !== o && (n = (o = r) && function (t) { this.setAttributeNS(e.space, e.local, r.call(this, t)) }), n } return r._value = t, r } : function (e, t) { var n, o; function r() { var r = t.apply(this, arguments); return r !== o && (n = (o = r) && function (t) { this.setAttribute(e, r.call(this, t)) }), n } return r._value = t, r })(o, t)) }, style: function (e, t, n) { var o, r, i, a, l, s, u, c, d, h, f, p, g, m, y, x, v, b, w, S, _, M = "transform" == (e += "") ? e6 : tO; return null == t ? this.styleTween(e, (o = e, function () { var e = Z(this, o), t = (this.style.removeProperty(o), Z(this, o)); return e === t ? null : e === r && t === i ? a : a = M(r = e, i = t) })).on("end.style." + e, tV(e)) : "function" == typeof t ? this.styleTween(e, (l = e, s = e9(this, "style." + e, t), function () { var e = Z(this, l), t = s(this), n = t + ""; return null == t && (this.style.removeProperty(l), n = t = Z(this, l)), e === n ? null : e === u && n === c ? d : (c = n, d = M(u = e, t)) })).each((h = this._id, v = "end." + (x = "style." + (f = e)), function () { var e = eQ(this, h), t = e.on, n = null == e.value[x] ? y || (y = tV(f)) : void 0; (t !== p || m !== n) && (g = (p = t).copy()).on(v, m = n), e.on = g })) : this.styleTween(e, (b = e, _ = t + "", function () { var e = Z(this, b); return e === _ ? null : e === w ? S : S = M(w = e, t) }), n).on("end.style." + e, null) }, styleTween: function (e, t, n) { var o = "style." + (e += ""); if (arguments.length < 2) return (o = this.tween(o)) && o._value; if (null == t) return this.tween(o, null); if ("function" != typeof t) throw Error(); return this.tween(o, function (e, t, n) { var o, r; function i() { var i = t.apply(this, arguments); return i !== r && (o = (r = i) && function (t) { this.style.setProperty(e, i.call(this, t), n) }), o } return i._value = t, i }(e, t, null == n ? "" : n)) }, text: function (e) { var t, n; return this.tween("text", "function" == typeof e ? (t = e9(this, "text", e), function () { var e = t(this); this.textContent = null == e ? "" : e }) : (n = null == e ? "" : e + "", function () { this.textContent = n })) }, textTween: function (e) { var t = "text"; if (arguments.length < 1) return (t = this.tween(t)) && t._value; if (null == e) return this.tween(t, null); if ("function" != typeof e) throw Error(); return this.tween(t, function (e) { var t, n; function o() { var o = e.apply(this, arguments); return o !== n && (t = (n = o) && function (e) { this.textContent = o.call(this, e) }), t } return o._value = e, o }(e)) }, remove: function () { var e; return this.on("end.remove", (e = this._id, function () { var t = this.parentNode; for (var n in this.__transition) if (+n !== e) return; t && t.removeChild(this) })) }, tween: function (e, t) { var n = this._id; if (e += "", arguments.length < 2) { for (var o, r = eJ(this.node(), n).tween, i = 0, a = r.length; i < a; ++i)if ((o = r[i]).name === e) return o.value; return null } return this.each((null == t ? function (e, t) { var n, o; return function () { var r = eQ(this, e), i = r.tween; if (i !== n) { o = n = i; for (var a = 0, l = o.length; a < l; ++a)if (o[a].name === t) { (o = o.slice()).splice(a, 1); break } } r.tween = o } } : function (e, t, n) { var o, r; if ("function" != typeof n) throw Error(); return function () { var i = eQ(this, e), a = i.tween; if (a !== o) { r = (o = a).slice(); for (var l = { name: t, value: n }, s = 0, u = r.length; s < u; ++s)if (r[s].name === t) { r[s] = l; break } s === u && r.push(l) } i.tween = r } })(n, e, t)) }, delay: function (e) { var t = this._id; return arguments.length ? this.each(("function" == typeof e ? function (e, t) { return function () { eG(this, e).delay = +t.apply(this, arguments) } } : function (e, t) { return t *= 1, function () { eG(this, e).delay = t } })(t, e)) : eJ(this.node(), t).delay }, duration: function (e) { var t = this._id; return arguments.length ? this.each(("function" == typeof e ? function (e, t) { return function () { eQ(this, e).duration = +t.apply(this, arguments) } } : function (e, t) { return t *= 1, function () { eQ(this, e).duration = t } })(t, e)) : eJ(this.node(), t).duration }, ease: function (e) { var t = this._id; return arguments.length ? this.each(function (e, t) { if ("function" != typeof t) throw Error(); return function () { eQ(this, e).ease = t } }(t, e)) : eJ(this.node(), t).ease }, easeVarying: function (e) { var t; if ("function" != typeof e) throw Error(); return this.each((t = this._id, function () { var n = e.apply(this, arguments); if ("function" != typeof n) throw Error(); eQ(this, t).ease = n })) }, end: function () { var e, t, n = this, o = n._id, r = n.size(); return new Promise(function (i, a) { var l = { value: a }, s = { value: function () { 0 == --r && i() } }; n.each(function () { var n = eQ(this, o), r = n.on; r !== e && ((t = (e = r).copy())._.cancel.push(l), t._.interrupt.push(l), t._.end.push(s)), n.on = t }), 0 === r && i() }) }, [Symbol.iterator]: tX[Symbol.iterator] }; var tY = { time: null, delay: 0, duration: 250, ease: function (e) { return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2 } }; eh.prototype.interrupt = function (e) { return this.each(function () { e0(this, e) }) }, eh.prototype.transition = function (e) { var t, n; e instanceof tF ? (t = e._id, e = e._name) : (t = ++tH, (n = tY).time = eB(), e = null == e ? null : e + ""); for (var o = this._groups, r = o.length, i = 0; i < r; ++i)for (var a, l = o[i], s = l.length, u = 0; u < s; ++u)(a = l[u]) && eU(a, e, t, u, l, n || function (e, t) { for (var n; !(n = e.__transition) || !(n = n[t]);)if (!(e = e.parentNode)) throw Error(`transition ${t} not found`); return n }(a, t)); return new tF(o, this._parents, e, t) }; let tZ = e => () => e; function tK(e, { sourceEvent: t, target: n, transform: o, dispatch: r }) { Object.defineProperties(this, { type: { value: e, enumerable: !0, configurable: !0 }, sourceEvent: { value: t, enumerable: !0, configurable: !0 }, target: { value: n, enumerable: !0, configurable: !0 }, transform: { value: o, enumerable: !0, configurable: !0 }, _: { value: r } }) } function tq(e, t, n) { this.k = e, this.x = t, this.y = n } tq.prototype = { constructor: tq, scale: function (e) { return 1 === e ? this : new tq(this.k * e, this.x, this.y) }, translate: function (e, t) { return 0 === e & 0 === t ? this : new tq(this.k, this.x + this.k * e, this.y + this.k * t) }, apply: function (e) { return [e[0] * this.k + this.x, e[1] * this.k + this.y] }, applyX: function (e) { return e * this.k + this.x }, applyY: function (e) { return e * this.k + this.y }, invert: function (e) { return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k] }, invertX: function (e) { return (e - this.x) / this.k }, invertY: function (e) { return (e - this.y) / this.k }, rescaleX: function (e) { return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e)) }, rescaleY: function (e) { return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e)) }, toString: function () { return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")" } }; var tW = new tq(1, 0, 0); function tU(e) { for (; !e.__zoom;)if (!(e = e.parentNode)) return tW; return e.__zoom } function tG(e) { e.stopImmediatePropagation() } function tQ(e) { e.preventDefault(), e.stopImmediatePropagation() } function tJ(e) { return (!e.ctrlKey || "wheel" === e.type) && !e.button } function t0() { var e = this; return e instanceof SVGElement ? (e = e.ownerSVGElement || e).hasAttribute("viewBox") ? [[(e = e.viewBox.baseVal).x, e.y], [e.x + e.width, e.y + e.height]] : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]] : [[0, 0], [e.clientWidth, e.clientHeight]] } function t1() { return this.__zoom || tW } function t2(e) { return -e.deltaY * (1 === e.deltaMode ? .05 : e.deltaMode ? 1 : .002) * (e.ctrlKey ? 10 : 1) } function t5() { return navigator.maxTouchPoints || "ontouchstart" in this } function t3(e, t, n) { var o = e.invertX(t[0][0]) - n[0][0], r = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1]; return e.translate(r > o ? (o + r) / 2 : Math.min(0, o) || Math.max(0, r), a > i ? (i + a) / 2 : Math.min(0, i) || Math.max(0, a)) } function t4() { var e, t, n, o = tJ, r = t0, i = t3, a = t2, l = t5, s = [0, 1 / 0], u = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], c = 250, d = eA, h = _("start", "zoom", "end"), f = 0, p = 10; function g(e) { e.property("__zoom", t1).on("wheel.zoom", S, { passive: !1 }).on("mousedown.zoom", M).on("dblclick.zoom", E).filter(l).on("touchstart.zoom", k).on("touchmove.zoom", C).on("touchend.zoom touchcancel.zoom", N).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function m(e, t) { return (t = Math.max(s[0], Math.min(s[1], t))) === e.k ? e : new tq(t, e.x, e.y) } function y(e, t, n) { var o = t[0] - n[0] * e.k, r = t[1] - n[1] * e.k; return o === e.x && r === e.y ? e : new tq(e.k, o, r) } function x(e) { return [(+e[0][0] + +e[1][0]) / 2, (+e[0][1] + +e[1][1]) / 2] } function v(e, t, n, o) { e.on("start.zoom", function () { b(this, arguments).event(o).start() }).on("interrupt.zoom end.zoom", function () { b(this, arguments).event(o).end() }).tween("zoom", function () { var e = arguments, i = b(this, e).event(o), a = r.apply(this, e), l = null == n ? x(a) : "function" == typeof n ? n.apply(this, e) : n, s = Math.max(a[1][0] - a[0][0], a[1][1] - a[0][1]), u = this.__zoom, c = "function" == typeof t ? t.apply(this, e) : t, h = d(u.invert(l).concat(s / u.k), c.invert(l).concat(s / c.k)); return function (e) { if (1 === e) e = c; else { var t = h(e), n = s / t[2]; e = new tq(n, l[0] - t[0] * n, l[1] - t[1] * n) } i.zoom(null, e) } }) } function b(e, t, n) { return !n && e.__zooming || new w(e, t) } function w(e, t) { this.that = e, this.args = t, this.active = 0, this.sourceEvent = null, this.extent = r.apply(e, t), this.taps = 0 } function S(e, ...t) { if (o.apply(this, arguments)) { var n = b(this, t).event(e), r = this.__zoom, l = Math.max(s[0], Math.min(s[1], r.k * Math.pow(2, a.apply(this, arguments)))), c = ep(e); if (n.wheel) (n.mouse[0][0] !== c[0] || n.mouse[0][1] !== c[1]) && (n.mouse[1] = r.invert(n.mouse[0] = c)), clearTimeout(n.wheel); else { if (r.k === l) return; n.mouse = [c, r.invert(c)], e0(this), n.start() } tQ(e), n.wheel = setTimeout(function () { n.wheel = null, n.end() }, 150), n.zoom("mouse", i(y(m(r, l), n.mouse[0], n.mouse[1]), n.extent, u)) } } function M(e, ...t) { if (!n && o.apply(this, arguments)) { var r = e.currentTarget, a = b(this, t, !0).event(e), l = ef(e.view).on("mousemove.zoom", function (e) { if (tQ(e), !a.moved) { var t = e.clientX - c, n = e.clientY - d; a.moved = t * t + n * n > f } a.event(e).zoom("mouse", i(y(a.that.__zoom, a.mouse[0] = ep(e, r), a.mouse[1]), a.extent, u)) }, !0).on("mouseup.zoom", function (e) { l.on("mousemove.zoom mouseup.zoom", null), eb(e.view, a.moved), tQ(e), a.event(e).end() }, !0), s = ep(e, r), c = e.clientX, d = e.clientY; ev(e.view), tG(e), a.mouse = [s, this.__zoom.invert(s)], e0(this), a.start() } } function E(e, ...t) { if (o.apply(this, arguments)) { var n = this.__zoom, a = ep(e.changedTouches ? e.changedTouches[0] : e, this), l = n.invert(a), s = n.k * (e.shiftKey ? .5 : 2), d = i(y(m(n, s), a, l), r.apply(this, t), u); tQ(e), c > 0 ? ef(this).transition().duration(c).call(v, d, a, e) : ef(this).call(g.transform, d, a, e) } } function k(n, ...r) { if (o.apply(this, arguments)) { var i, a, l, s, u = n.touches, c = u.length, d = b(this, r, n.changedTouches.length === c).event(n); for (tG(n), a = 0; a < c; ++a)s = [s = ep(l = u[a], this), this.__zoom.invert(s), l.identifier], d.touch0 ? d.touch1 || d.touch0[2] === s[2] || (d.touch1 = s, d.taps = 0) : (d.touch0 = s, i = !0, d.taps = 1 + !!e); e && (e = clearTimeout(e)), i && (d.taps < 2 && (t = s[0], e = setTimeout(function () { e = null }, 500)), e0(this), d.start()) } } function C(e, ...t) { if (this.__zooming) { var n, o, r, a, l = b(this, t).event(e), s = e.changedTouches, c = s.length; for (tQ(e), n = 0; n < c; ++n)r = ep(o = s[n], this), l.touch0 && l.touch0[2] === o.identifier ? l.touch0[0] = r : l.touch1 && l.touch1[2] === o.identifier && (l.touch1[0] = r); if (o = l.that.__zoom, l.touch1) { var d = l.touch0[0], h = l.touch0[1], f = l.touch1[0], p = l.touch1[1], g = (g = f[0] - d[0]) * g + (g = f[1] - d[1]) * g, x = (x = p[0] - h[0]) * x + (x = p[1] - h[1]) * x; o = m(o, Math.sqrt(g / x)), r = [(d[0] + f[0]) / 2, (d[1] + f[1]) / 2], a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2] } else { if (!l.touch0) return; r = l.touch0[0], a = l.touch0[1] } l.zoom("touch", i(y(o, r, a), l.extent, u)) } } function N(e, ...o) { if (this.__zooming) { var r, i, a = b(this, o).event(e), l = e.changedTouches, s = l.length; for (tG(e), n && clearTimeout(n), n = setTimeout(function () { n = null }, 500), r = 0; r < s; ++r)i = l[r], a.touch0 && a.touch0[2] === i.identifier ? delete a.touch0 : a.touch1 && a.touch1[2] === i.identifier && delete a.touch1; if (a.touch1 && !a.touch0 && (a.touch0 = a.touch1, delete a.touch1), a.touch0) a.touch0[1] = this.__zoom.invert(a.touch0[0]); else if (a.end(), 2 === a.taps && (i = ep(i, this), Math.hypot(t[0] - i[0], t[1] - i[1]) < p)) { var u = ef(this).on("dblclick.zoom"); u && u.apply(this, arguments) } } } return g.transform = function (e, t, n, o) { var r = e.selection ? e.selection() : e; r.property("__zoom", t1), e !== r ? v(e, t, n, o) : r.interrupt().each(function () { b(this, arguments).event(o).start().zoom(null, "function" == typeof t ? t.apply(this, arguments) : t).end() }) }, g.scaleBy = function (e, t, n, o) { g.scaleTo(e, function () { var e = this.__zoom.k, n = "function" == typeof t ? t.apply(this, arguments) : t; return e * n }, n, o) }, g.scaleTo = function (e, t, n, o) { g.transform(e, function () { var e = r.apply(this, arguments), o = this.__zoom, a = null == n ? x(e) : "function" == typeof n ? n.apply(this, arguments) : n, l = o.invert(a), s = "function" == typeof t ? t.apply(this, arguments) : t; return i(y(m(o, s), a, l), e, u) }, n, o) }, g.translateBy = function (e, t, n, o) { g.transform(e, function () { return i(this.__zoom.translate("function" == typeof t ? t.apply(this, arguments) : t, "function" == typeof n ? n.apply(this, arguments) : n), r.apply(this, arguments), u) }, null, o) }, g.translateTo = function (e, t, n, o, a) { g.transform(e, function () { var e = r.apply(this, arguments), a = this.__zoom, l = null == o ? x(e) : "function" == typeof o ? o.apply(this, arguments) : o; return i(tW.translate(l[0], l[1]).scale(a.k).translate("function" == typeof t ? -t.apply(this, arguments) : -t, "function" == typeof n ? -n.apply(this, arguments) : -n), e, u) }, o, a) }, w.prototype = { event: function (e) { return e && (this.sourceEvent = e), this }, start: function () { return 1 == ++this.active && (this.that.__zooming = this, this.emit("start")), this }, zoom: function (e, t) { return this.mouse && "mouse" !== e && (this.mouse[1] = t.invert(this.mouse[0])), this.touch0 && "touch" !== e && (this.touch0[1] = t.invert(this.touch0[0])), this.touch1 && "touch" !== e && (this.touch1[1] = t.invert(this.touch1[0])), this.that.__zoom = t, this.emit("zoom"), this }, end: function () { return 0 == --this.active && (delete this.that.__zooming, this.emit("end")), this }, emit: function (e) { var t = ef(this.that).datum(); h.call(e, this.that, new tK(e, { sourceEvent: this.sourceEvent, target: g, type: e, transform: this.that.__zoom, dispatch: h }), t) } }, g.wheelDelta = function (e) { return arguments.length ? (a = "function" == typeof e ? e : tZ(+e), g) : a }, g.filter = function (e) { return arguments.length ? (o = "function" == typeof e ? e : tZ(!!e), g) : o }, g.touchable = function (e) { return arguments.length ? (l = "function" == typeof e ? e : tZ(!!e), g) : l }, g.extent = function (e) { return arguments.length ? (r = "function" == typeof e ? e : tZ([[+e[0][0], +e[0][1]], [+e[1][0], +e[1][1]]]), g) : r }, g.scaleExtent = function (e) { return arguments.length ? (s[0] = +e[0], s[1] = +e[1], g) : [s[0], s[1]] }, g.translateExtent = function (e) { return arguments.length ? (u[0][0] = +e[0][0], u[1][0] = +e[1][0], u[0][1] = +e[0][1], u[1][1] = +e[1][1], g) : [[u[0][0], u[0][1]], [u[1][0], u[1][1]]] }, g.constrain = function (e) { return arguments.length ? (i = e, g) : i }, g.duration = function (e) { return arguments.length ? (c = +e, g) : c }, g.interpolate = function (e) { return arguments.length ? (d = e, g) : d }, g.on = function () { var e = h.on.apply(h, arguments); return e === h ? g : e }, g.clickDistance = function (e) { return arguments.length ? (f = (e *= 1) * e, g) : Math.sqrt(f) }, g.tapDistance = function (e) { return arguments.length ? (p = +e, g) : p }, g } function t6(e, t) { var n, o, r = typeof t; return null == t || "boolean" === r ? tz(t) : ("number" === r ? e1 : "string" === r ? (o = tg(t)) ? (t = o, tD) : tL : t instanceof tg ? tD : t instanceof Date ? function (e, t) { var n = new Date; return e *= 1, t *= 1, function (o) { return n.setTime(e * (1 - o) + t * o), n } } : !ArrayBuffer.isView(n = t) || n instanceof DataView ? Array.isArray(t) ? function (e, t) { var n, o = t ? t.length : 0, r = e ? Math.min(o, e.length) : 0, i = Array(r), a = Array(o); for (n = 0; n < r; ++n)i[n] = t6(e[n], t[n]); for (; n < o; ++n)a[n] = t[n]; return function (e) { for (n = 0; n < r; ++n)a[n] = i[n](e); return a } } : "function" != typeof t.valueOf && "function" != typeof t.toString || isNaN(t) ? function (e, t) { var n, o = {}, r = {}; for (n in (null === e || "object" != typeof e) && (e = {}), (null === t || "object" != typeof t) && (t = {}), t) n in e ? o[n] = t6(e[n], t[n]) : r[n] = t[n]; return function (e) { for (n in o) r[n] = o[n](e); return r } } : e1 : function (e, t) { t || (t = []); var n, o = e ? Math.min(t.length, e.length) : 0, r = t.slice(); return function (i) { for (n = 0; n < o; ++n)r[n] = e[n] * (1 - i) + t[n] * i; return r } })(e, t) } tU.prototype = tq.prototype; let t8 = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], t9 = ["Enter", " ", "Escape"], t7 = { "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.", "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.", "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`, "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.", "controls.ariaLabel": "Control Panel", "controls.zoomIn.ariaLabel": "Zoom In", "controls.zoomOut.ariaLabel": "Zoom Out", "controls.fitView.ariaLabel": "Fit View", "controls.interactive.ariaLabel": "Toggle Interactivity", "minimap.ariaLabel": "Mini Map", "handle.ariaLabel": "Handle" }; (t = c || (c = {})).Strict = "strict", t.Loose = "loose", (n = d || (d = {})).Free = "free", n.Vertical = "vertical", n.Horizontal = "horizontal", (o = h || (h = {})).Partial = "partial", o.Full = "full"; let ne = { inProgress: !1, isValid: null, from: null, fromHandle: null, fromPosition: null, fromNode: null, to: null, toHandle: null, toPosition: null, toNode: null, pointer: null }; (r = f || (f = {})).Bezier = "default", r.Straight = "straight", r.Step = "step", r.SmoothStep = "smoothstep", r.SimpleBezier = "simplebezier", (i = p || (p = {})).Arrow = "arrow", i.ArrowClosed = "arrowclosed", (a = g || (g = {})).Left = "left", a.Top = "top", a.Right = "right", a.Bottom = "bottom"; let nt = { [g.Left]: g.Right, [g.Right]: g.Left, [g.Top]: g.Bottom, [g.Bottom]: g.Top }; function nn(e) { return null === e ? null : e ? "valid" : "invalid" } let no = e => "id" in e && "source" in e && "target" in e, nr = e => "id" in e && "internals" in e && !("source" in e) && !("target" in e), ni = (e, t = [0, 0]) => { let { width: n, height: o } = n$(e), r = e.origin ?? t, i = n * r[0], a = o * r[1]; return { x: e.position.x - i, y: e.position.y - a } }, na = (e, t = {}) => { let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, o = !1; return e.forEach(e => { (void 0 === t.filter || t.filter(e)) && (n = nm(n, nb(e)), o = !0) }), o ? nx(n) : { x: 0, y: 0, width: 0, height: 0 } }, nl = (e, t, [n, o, r] = [0, 0, 1], i = !1, a = !1) => { let l = { ...nC(t, [n, o, r]), width: t.width / r, height: t.height / r }, s = []; for (let t of e.values()) { let { measured: e, selectable: n = !0, hidden: o = !1 } = t; if (a && !n || o) continue; let r = e.width ?? t.width ?? t.initialWidth ?? null, u = e.height ?? t.height ?? t.initialHeight ?? null, c = nS(l, nv(t)), d = (r ?? 0) * (u ?? 0), h = i && c > 0; (!t.internals.handleBounds || h || c >= d || t.dragging) && s.push(t) } return s }; async function ns({ nodes: e, width: t, height: n, panZoom: o, minZoom: r, maxZoom: i }, a) { let l, s; if (0 === e.size) return Promise.resolve(!0); let u = nj(na((l = new Map, s = a?.nodes ? new Set(a.nodes.map(e => e.id)) : null, e.forEach(e => { e.measured.width && e.measured.height && (a?.includeHiddenNodes || !e.hidden) && (!s || s.has(e.id)) && l.set(e.id, e) }), l)), t, n, a?.minZoom ?? r, a?.maxZoom ?? i, a?.padding ?? .1); return await o.setViewport(u, { duration: a?.duration, ease: a?.ease, interpolate: a?.interpolate }), Promise.resolve(!0) } function nu({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: o = [0, 0], nodeExtent: r, onError: i }) { let a = n.get(e), l = a.parentId ? n.get(a.parentId) : void 0, { x: s, y: u } = l ? l.internals.positionAbsolute : { x: 0, y: 0 }, c = a.origin ?? o, d = a.extent || r; if ("parent" !== a.extent || a.expandParent) l && nz(a.extent) && (d = [[a.extent[0][0] + s, a.extent[0][1] + u], [a.extent[1][0] + s, a.extent[1][1] + u]]); else if (l) { let e = l.measured.width, t = l.measured.height; e && t && (d = [[s, u], [s + e, u + t]]) } else i?.("005", "Only child nodes can use a parent extent."); let h = nz(d) ? nh(t, d, a.measured) : t; return (void 0 === a.measured.width || void 0 === a.measured.height) && i?.("015", "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."), { position: { x: h.x - s + (a.measured.width ?? 0) * c[0], y: h.y - u + (a.measured.height ?? 0) * c[1] }, positionAbsolute: h } } async function nc({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: o, onBeforeDelete: r }) { let i, a = new Set(e.map(e => e.id)), l = []; for (let e of n) { if (!1 === e.deletable) continue; let t = a.has(e.id), n = !t && e.parentId && l.find(t => t.id === e.parentId); (t || n) && l.push(e) } let s = new Set(t.map(e => e.id)), u = o.filter(e => !1 !== e.deletable), c = (i = new Set, l.forEach(e => { i.add(e.id) }), u.filter(e => i.has(e.source) || i.has(e.target))); for (let e of u) s.has(e.id) && !c.find(t => t.id === e.id) && c.push(e); if (!r) return { edges: c, nodes: l }; let d = await r({ nodes: l, edges: c }); return "boolean" == typeof d ? d ? { edges: c, nodes: l } : { edges: [], nodes: [] } : d } let nd = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), nh = (e = { x: 0, y: 0 }, t, n) => ({ x: nd(e.x, t[0][0], t[1][0] - (n?.width ?? 0)), y: nd(e.y, t[0][1], t[1][1] - (n?.height ?? 0)) }); function nf(e, t, n) { let { width: o, height: r } = n$(n), { x: i, y: a } = n.internals.positionAbsolute; return nh(e, [[i, a], [i + o, a + r]], t) } let np = (e, t, n) => e < t ? nd(Math.abs(e - t), 1, t) / t : e > n ? -nd(Math.abs(e - n), 1, t) / t : 0, ng = (e, t, n = 15, o = 40) => [np(e.x, o, t.width - o) * n, np(e.y, o, t.height - o) * n], nm = (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), x2: Math.max(e.x2, t.x2), y2: Math.max(e.y2, t.y2) }), ny = ({ x: e, y: t, width: n, height: o }) => ({ x: e, y: t, x2: e + n, y2: t + o }), nx = ({ x: e, y: t, x2: n, y2: o }) => ({ x: e, y: t, width: n - e, height: o - t }), nv = (e, t = [0, 0]) => { let { x: n, y: o } = nr(e) ? e.internals.positionAbsolute : ni(e, t); return { x: n, y: o, width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0, height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0 } }, nb = (e, t = [0, 0]) => { let { x: n, y: o } = nr(e) ? e.internals.positionAbsolute : ni(e, t); return { x: n, y: o, x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0), y2: o + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0) } }, nw = (e, t) => nx(nm(ny(e), ny(t))), nS = (e, t) => Math.ceil(Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)) * Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y))), n_ = e => nM(e.width) && nM(e.height) && nM(e.x) && nM(e.y), nM = e => !isNaN(e) && isFinite(e), nE = (e, t) => { }, nk = (e, t = [1, 1]) => ({ x: t[0] * Math.round(e.x / t[0]), y: t[1] * Math.round(e.y / t[1]) }), nC = ({ x: e, y: t }, [n, o, r], i = !1, a = [1, 1]) => { let l = { x: (e - n) / r, y: (t - o) / r }; return i ? nk(l, a) : l }, nN = ({ x: e, y: t }, [n, o, r]) => ({ x: e * r + n, y: t * r + o }); function nA(e, t) { if ("number" == typeof e) return Math.floor((t - t / (1 + e)) * .5); if ("string" == typeof e && e.endsWith("px")) { let t = parseFloat(e); if (!Number.isNaN(t)) return Math.floor(t) } if ("string" == typeof e && e.endsWith("%")) { let n = parseFloat(e); if (!Number.isNaN(n)) return Math.floor(t * n * .01) } return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0 } let nj = (e, t, n, o, r, i) => { let a = function (e, t, n) { if ("string" == typeof e || "number" == typeof e) { let o = nA(e, n), r = nA(e, t); return { top: o, right: r, bottom: o, left: r, x: 2 * r, y: 2 * o } } if ("object" == typeof e) { let o = nA(e.top ?? e.y ?? 0, n), r = nA(e.bottom ?? e.y ?? 0, n), i = nA(e.left ?? e.x ?? 0, t), a = nA(e.right ?? e.x ?? 0, t); return { top: o, right: a, bottom: r, left: i, x: i + a, y: o + r } } return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 } }(i, t, n), l = nd(Math.min((t - a.x) / e.width, (n - a.y) / e.height), o, r), s = e.x + e.width / 2, u = e.y + e.height / 2, c = t / 2 - s * l, d = n / 2 - u * l, h = function (e, t, n, o, r, i) { let { x: a, y: l } = nN(e, [t, n, o]), { x: s, y: u } = nN({ x: e.x + e.width, y: e.y + e.height }, [t, n, o]); return { left: Math.floor(a), top: Math.floor(l), right: Math.floor(r - s), bottom: Math.floor(i - u) } }(e, c, d, l, t, n), f = { left: Math.min(h.left - a.left, 0), top: Math.min(h.top - a.top, 0), right: Math.min(h.right - a.right, 0), bottom: Math.min(h.bottom - a.bottom, 0) }; return { x: c - f.left + f.right, y: d - f.top + f.bottom, zoom: l } }, nP = () => "u" > typeof navigator && navigator?.userAgent?.indexOf("Mac") >= 0; function nz(e) { return null != e && "parent" !== e } function n$(e) { return { width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0, height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0 } } function nD(e) { return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0 } function nI(e, t = { width: 0, height: 0 }, n, o, r) { let i = { ...e }, a = o.get(n); if (a) { let e = a.origin || r; i.x += a.internals.positionAbsolute.x - (t.width ?? 0) * e[0], i.y += a.internals.positionAbsolute.y - (t.height ?? 0) * e[1] } return i } function nT(e, t) { if (e.size !== t.size) return !1; for (let n of e) if (!t.has(n)) return !1; return !0 } function nR(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: o, containerBounds: r }) { let { x: i, y: a } = nH(e), l = nC({ x: i - (r?.left ?? 0), y: a - (r?.top ?? 0) }, o), { x: s, y: u } = n ? nk(l, t) : l; return { xSnapped: s, ySnapped: u, ...l } } let nL = e => ({ width: e.offsetWidth, height: e.offsetHeight }), nO = e => e?.getRootNode?.() || window?.document, nB = ["INPUT", "SELECT", "TEXTAREA"]; function nV(e) { let t = e.composedPath?.()?.[0] || e.target; return t?.nodeType === 1 && (nB.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey")) } let nH = (e, t) => { let n = "clientX" in e, o = n ? e.clientX : e.touches?.[0].clientX, r = n ? e.clientY : e.touches?.[0].clientY; return { x: o - (t?.left ?? 0), y: r - (t?.top ?? 0) } }, nF = (e, t, n, o, r) => { let i = t.querySelectorAll(`.${e}`); return i && i.length ? Array.from(i).map(t => { let i = t.getBoundingClientRect(); return { id: t.getAttribute("data-handleid"), type: e, nodeId: r, position: t.getAttribute("data-handlepos"), x: (i.left - n.left) / o, y: (i.top - n.top) / o, ...nL(t) } }) : null }; function nX({ sourceX: e, sourceY: t, targetX: n, targetY: o, sourceControlX: r, sourceControlY: i, targetControlX: a, targetControlY: l }) { let s = .125 * e + .375 * r + .375 * a + .125 * n, u = .125 * t + .375 * i + .375 * l + .125 * o, c = Math.abs(s - e), d = Math.abs(u - t); return [s, u, c, d] } function nY(e, t) { return e >= 0 ? .5 * e : 25 * t * Math.sqrt(-e) } function nZ({ pos: e, x1: t, y1: n, x2: o, y2: r, c: i }) { switch (e) { case g.Left: return [t - nY(t - o, i), n]; case g.Right: return [t + nY(o - t, i), n]; case g.Top: return [t, n - nY(n - r, i)]; case g.Bottom: return [t, n + nY(r - n, i)] } } function nK({ sourceX: e, sourceY: t, sourcePosition: n = g.Bottom, targetX: o, targetY: r, targetPosition: i = g.Top, curvature: a = .25 }) { let [l, s] = nZ({ pos: n, x1: e, y1: t, x2: o, y2: r, c: a }), [u, c] = nZ({ pos: i, x1: o, y1: r, x2: e, y2: t, c: a }), [d, h, f, p] = nX({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: l, sourceControlY: s, targetControlX: u, targetControlY: c }); return [`M${e},${t} C${l},${s} ${u},${c} ${o},${r}`, d, h, f, p] } function nq({ sourceX: e, sourceY: t, targetX: n, targetY: o }) { let r = Math.abs(n - e) / 2, i = Math.abs(o - t) / 2; return [n < e ? n + r : n - r, o < t ? o + i : o - i, r, i] } let nW = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `xy-edge__${e}${t || ""}-${n}${o || ""}`, nU = (e, t, n = {}) => { let o, r; if (!e.source || !e.target) return nE("006", "Can't create edge. An edge needs a source and a target."), t; let i = n.getEdgeId || nW; return (r = o = no(e) ? { ...e } : { ...e, id: i(e) }, t.some(e => e.source === r.source && e.target === r.target && (e.sourceHandle === r.sourceHandle || !e.sourceHandle && !r.sourceHandle) && (e.targetHandle === r.targetHandle || !e.targetHandle && !r.targetHandle))) ? t : (null === o.sourceHandle && delete o.sourceHandle, null === o.targetHandle && delete o.targetHandle, t.concat(o)) }; function nG({ sourceX: e, sourceY: t, targetX: n, targetY: o }) { let [r, i, a, l] = nq({ sourceX: e, sourceY: t, targetX: n, targetY: o }); return [`M ${e},${t}L ${n},${o}`, r, i, a, l] } let nQ = { [g.Left]: { x: -1, y: 0 }, [g.Right]: { x: 1, y: 0 }, [g.Top]: { x: 0, y: -1 }, [g.Bottom]: { x: 0, y: 1 } }, nJ = ({ source: e, sourcePosition: t = g.Bottom, target: n }) => t === g.Left || t === g.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, n0 = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)); function n1({ sourceX: e, sourceY: t, sourcePosition: n = g.Bottom, targetX: o, targetY: r, targetPosition: i = g.Top, borderRadius: a = 5, centerX: l, centerY: s, offset: u = 20, stepPosition: c = .5 }) { let [d, h, f, p, m] = function ({ source: e, sourcePosition: t = g.Bottom, target: n, targetPosition: o = g.Top, center: r, offset: i, stepPosition: a }) { let l, s, u = nQ[t], c = nQ[o], d = { x: e.x + u.x * i, y: e.y + u.y * i }, h = { x: n.x + c.x * i, y: n.y + c.y * i }, f = nJ({ source: d, sourcePosition: t, target: h }), p = 0 !== f.x ? "x" : "y", m = f[p], y = [], x = { x: 0, y: 0 }, v = { x: 0, y: 0 }, [, , b, w] = nq({ sourceX: e.x, sourceY: e.y, targetX: n.x, targetY: n.y }); if (u[p] * c[p] == -1) { "x" === p ? (l = r.x ?? d.x + (h.x - d.x) * a, s = r.y ?? (d.y + h.y) / 2) : (l = r.x ?? (d.x + h.x) / 2, s = r.y ?? d.y + (h.y - d.y) * a); let e = [{ x: l, y: d.y }, { x: l, y: h.y }], t = [{ x: d.x, y: s }, { x: h.x, y: s }]; y = u[p] === m ? "x" === p ? e : t : "x" === p ? t : e } else { let r = [{ x: d.x, y: h.y }], a = [{ x: h.x, y: d.y }]; if (y = "x" === p ? u.x === m ? a : r : u.y === m ? r : a, t === o) { let t = Math.abs(e[p] - n[p]); if (t <= i) { let o = Math.min(i - 1, i - t); u[p] === m ? x[p] = (d[p] > e[p] ? -1 : 1) * o : v[p] = (h[p] > n[p] ? -1 : 1) * o } } if (t !== o) { let e = "x" === p ? "y" : "x", t = u[p] === c[e], n = d[e] > h[e], o = d[e] < h[e]; (1 === u[p] && (!t && n || t && o) || 1 !== u[p] && (!t && o || t && n)) && (y = "x" === p ? r : a) } let f = { x: d.x + x.x, y: d.y + x.y }, g = { x: h.x + v.x, y: h.y + v.y }; Math.max(Math.abs(f.x - y[0].x), Math.abs(g.x - y[0].x)) >= Math.max(Math.abs(f.y - y[0].y), Math.abs(g.y - y[0].y)) ? (l = (f.x + g.x) / 2, s = y[0].y) : (l = y[0].x, s = (f.y + g.y) / 2) } return [[e, { x: d.x + x.x, y: d.y + x.y }, ...y, { x: h.x + v.x, y: h.y + v.y }, n], l, s, b, w] }({ source: { x: e, y: t }, sourcePosition: n, target: { x: o, y: r }, targetPosition: i, center: { x: l, y: s }, offset: u, stepPosition: c }); return [d.reduce((e, t, n) => e + (n > 0 && n < d.length - 1 ? function (e, t, n, o) { let r = Math.min(n0(e, t) / 2, n0(t, n) / 2, o), { x: i, y: a } = t; if (e.x === i && i === n.x || e.y === a && a === n.y) return `L${i} ${a}`; if (e.y === a) { let t = e.x < n.x ? -1 : 1, o = e.y < n.y ? 1 : -1; return `L ${i + r * t},${a}Q ${i},${a} ${i},${a + r * o}` } let l = e.x < n.x ? 1 : -1, s = e.y < n.y ? -1 : 1; return `L ${i},${a + r * s}Q ${i},${a} ${i + r * l},${a}` }(d[n - 1], t, d[n + 1], a) : `${0 === n ? "M" : "L"}${t.x} ${t.y}`), ""), h, f, p, m] } function n2(e) { return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth) } function n5(e) { if (!e) return null; let t = [], n = []; for (let o of e) o.width = o.width ?? 1, o.height = o.height ?? 1, "source" === o.type ? t.push(o) : "target" === o.type && n.push(o); return { source: t, target: n } } function n3(e, t, n = g.Left, o = !1) { let r = (t?.x ?? 0) + e.internals.positionAbsolute.x, i = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: a, height: l } = t ?? n$(e); if (o) return { x: r + a / 2, y: i + l / 2 }; switch (t?.position ?? n) { case g.Top: return { x: r + a / 2, y: i }; case g.Right: return { x: r + a, y: i + l / 2 }; case g.Bottom: return { x: r + a / 2, y: i + l }; case g.Left: return { x: r, y: i + l / 2 } } } function n4(e, t) { return e && (t ? e.find(e => e.id === t) : e[0]) || null } function n6(e, t) { if (!e) return ""; if ("string" == typeof e) return e; let n = t ? `${t}__` : ""; return `${n}${Object.keys(e).sort().map(t => `${t}=${e[t]}`).join("&")}` } let n8 = { nodeOrigin: [0, 0], nodeExtent: t8, elevateNodesOnSelect: !0, zIndexMode: "basic", defaults: {} }, n9 = { ...n8, checkEquality: !0 }; function n7(e, t) { let n = { ...e }; for (let e in t) void 0 !== t[e] && (n[e] = t[e]); return n } function oe(e) { return "manual" === e } function ot(e, t, n, o = {}) { let r = n7(n9, o), i = { i: 0 }, a = new Map(t), l = r?.elevateNodesOnSelect && !oe(r.zIndexMode) ? 1e3 : 0, s = e.length > 0; for (let u of (t.clear(), n.clear(), e)) { let e = a.get(u.id); if (r.checkEquality && u === e?.internals.userNode) t.set(u.id, e); else { let n = nh(ni(u, r.nodeOrigin), nz(u.extent) ? u.extent : r.nodeExtent, n$(u)); e = { ...r.defaults, ...u, measured: { width: u.measured?.width, height: u.measured?.height }, internals: { positionAbsolute: n, handleBounds: function (e, t) { if (!e.handles) return e.measured ? t?.internals.handleBounds : void 0; let n = [], o = []; for (let t of e.handles) { let r = { id: t.id, width: t.width ?? 1, height: t.height ?? 1, nodeId: e.id, x: t.x, y: t.y, position: t.position, type: t.type }; "source" === t.type ? n.push(r) : "target" === t.type && o.push(r) } return { source: n, target: o } }(u, e), z: oo(u, l, r.zIndexMode), userNode: u } }, t.set(u.id, e) } void 0 !== e.measured && void 0 !== e.measured.width && void 0 !== e.measured.height || e.hidden || (s = !1), u.parentId && on(e, t, n, o, i) } return s } function on(e, t, n, o, r) { let { elevateNodesOnSelect: i, nodeOrigin: a, nodeExtent: l, zIndexMode: s } = n7(n8, o), u = e.parentId, c = t.get(u); if (!c) return void console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`); !function (e, t) { if (!e.parentId) return; let n = t.get(e.parentId); n ? n.set(e.id, e) : t.set(e.parentId, new Map([[e.id, e]])) }(e, n), r && !c.parentId && void 0 === c.internals.rootParentIndex && "auto" === s && (c.internals.rootParentIndex = ++r.i, c.internals.z = c.internals.z + 10 * r.i), r && void 0 !== c.internals.rootParentIndex && (r.i = c.internals.rootParentIndex); let { x: d, y: h, z: f } = function (e, t, n, o, r, i) { let { x: a, y: l } = t.internals.positionAbsolute, s = n$(e), u = ni(e, n), c = nz(e.extent) ? nh(u, e.extent, s) : u, d = nh({ x: a + c.x, y: l + c.y }, o, s); "parent" === e.extent && (d = nf(d, s, t)); let h = oo(e, r, i), f = t.internals.z ?? 0; return { x: d.x, y: d.y, z: f >= h ? f + 1 : h } }(e, c, a, l, i && !oe(s) ? 1e3 : 0, s), { positionAbsolute: p } = e.internals, g = d !== p.x || h !== p.y; (g || f !== e.internals.z) && t.set(e.id, { ...e, internals: { ...e.internals, positionAbsolute: g ? { x: d, y: h } : p, z: f } }) } function oo(e, t, n) { let o = nM(e.zIndex) ? e.zIndex : 0; return oe(n) ? o : o + (e.selected ? t : 0) } function or(e, t, n, o = [0, 0]) { let r = [], i = new Map; for (let n of e) { let e = t.get(n.parentId); if (!e) continue; let o = nw(i.get(n.parentId)?.expandedRect ?? nv(e), n.rect); i.set(n.parentId, { expandedRect: o, parent: e }) } return i.size > 0 && i.forEach(({ expandedRect: t, parent: i }, a) => { let l = i.internals.positionAbsolute, s = n$(i), u = i.origin ?? o, c = t.x < l.x ? Math.round(Math.abs(l.x - t.x)) : 0, d = t.y < l.y ? Math.round(Math.abs(l.y - t.y)) : 0, h = Math.max(s.width, Math.round(t.width)), f = Math.max(s.height, Math.round(t.height)), p = (h - s.width) * u[0], g = (f - s.height) * u[1]; (c > 0 || d > 0 || p || g) && (r.push({ id: a, type: "position", position: { x: i.position.x - c + p, y: i.position.y - d + g } }), n.get(a)?.forEach(t => { e.some(e => e.id === t.id) || r.push({ id: t.id, type: "position", position: { x: t.position.x + c, y: t.position.y + d } }) })), (s.width < t.width || s.height < t.height || c || d) && r.push({ id: a, type: "dimensions", setAttributes: !0, dimensions: { width: h + (c ? u[0] * c - p : 0), height: f + (d ? u[1] * d - g : 0) } }) }), r } async function oi({ delta: e, panZoom: t, transform: n, translateExtent: o, width: r, height: i }) { if (!t || !e.x && !e.y) return Promise.resolve(!1); let a = await t.setViewportConstrained({ x: n[0] + e.x, y: n[1] + e.y, zoom: n[2] }, [[0, 0], [r, i]], o); return Promise.resolve(!!a && (a.x !== n[0] || a.y !== n[1] || a.k !== n[2])) } function oa(e, t, n, o, r, i) { let a = r, l = o.get(a) || new Map; o.set(a, l.set(n, t)), a = `${r}-${e}`; let s = o.get(a) || new Map; if (o.set(a, s.set(n, t)), i) { a = `${r}-${e}-${i}`; let l = o.get(a) || new Map; o.set(a, l.set(n, t)) } } function ol(e, t, n) { for (let o of (e.clear(), t.clear(), n)) { let { source: n, target: r, sourceHandle: i = null, targetHandle: a = null } = o, l = { edgeId: o.id, source: n, target: r, sourceHandle: i, targetHandle: a }, s = `${n}-${i}--${r}-${a}`; oa("source", l, `${r}-${a}--${n}-${i}`, e, n, i), oa("target", l, s, e, r, a), t.set(o.id, o) } } function os(e, t, n) { let o = e; do { if (o?.matches?.(t)) return !0; if (o === n) break; o = o?.parentElement } while (o) return !1 } function ou({ nodeId: e, dragItems: t, nodeLookup: n, dragging: o = !0 }) { let r = []; for (let [e, i] of t) { let t = n.get(e)?.internals.userNode; t && r.push({ ...t, position: i.position, dragging: o }) } if (!e) return [r[0], r]; let i = n.get(e)?.internals.userNode; return [i ? { ...i, position: t.get(e)?.position || i.position, dragging: o } : r[0], r] } function oc(e, t, n, o, r, i = !1) { let a = o.get(e); if (!a) return null; let l = "strict" === r ? a.internals.handleBounds?.[t] : [...a.internals.handleBounds?.source ?? [], ...a.internals.handleBounds?.target ?? []], s = (n ? l?.find(e => e.id === n) : l?.[0]) ?? null; return s && i ? { ...s, ...n3(a, s, s.position, !0) } : s } function od(e, t) { return e ? e : t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null } let oh = () => !0; function of(e, { handle: t, connectionMode: n, fromNodeId: o, fromHandleId: r, fromType: i, doc: a, lib: l, flowId: s, isValidConnection: u = oh, nodeLookup: d }) { let h = "target" === i, f = t ? a.querySelector(`.${l}-flow__handle[data-id="${s}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: p, y: g } = nH(e), m = a.elementFromPoint(p, g), y = m?.classList.contains(`${l}-flow__handle`) ? m : f, x = { handleDomNode: y, isValid: !1, connection: null, toHandle: null }; if (y) { let e = od(void 0, y), t = y.getAttribute("data-nodeid"), i = y.getAttribute("data-handleid"), a = y.classList.contains("connectable"), l = y.classList.contains("connectableend"); if (!t || !e) return x; let s = { source: h ? t : o, sourceHandle: h ? i : r, target: h ? o : t, targetHandle: h ? r : i }; x.connection = s, x.isValid = a && l && (n === c.Strict ? h && "source" === e || !h && "target" === e : t !== o || i !== r) && u(s), x.toHandle = oc(t, e, i, d, n, !0) } return x } let op = function (e, { connectionMode: t, connectionRadius: n, handleId: o, nodeId: r, edgeUpdaterType: i, isTarget: a, domNode: l, nodeLookup: s, lib: u, autoPanOnConnect: c, flowId: d, panBy: h, cancelConnection: f, onConnectStart: p, onConnect: m, onConnectEnd: y, isValidConnection: x = oh, onReconnectEnd: v, updateConnection: b, getTransform: w, getFromHandle: S, autoPanSpeed: _, dragThreshold: M = 1, handleDomNode: E }) { let k, C = nO(e.target), N = 0, { x: A, y: j } = nH(e), P = od(i, E), z = l?.getBoundingClientRect(), $ = !1; if (!z || !P) return; let D = oc(r, P, o, s, t); if (!D) return; let I = nH(e, z), T = !1, R = null, L = !1, O = null, B = { ...D, nodeId: r, type: P, position: D.position }, V = s.get(r), H = { inProgress: !0, isValid: null, from: n3(V, B, g.Left, !0), fromHandle: B, fromPosition: B.position, fromNode: V, to: I, toHandle: null, toPosition: nt[B.position], toNode: null, pointer: I }; function F() { $ = !0, b(H), p?.(e, { nodeId: r, handleId: o, handleType: P }) } function X(e) { var i, l; let f; if (!$) { let { x: t, y: n } = nH(e), o = t - A, r = n - j; if (!(o * o + r * r > M * M)) return; F() } if (!S() || !B) return void Y(e); let p = w(); k = function (e, t, n, o) { let r = [], i = 1 / 0; for (let a of function (e, t, n) { let o = [], r = { x: e.x - n, y: e.y - n, width: 2 * n, height: 2 * n }; for (let e of t.values()) nS(r, nv(e)) > 0 && o.push(e); return o }(e, n, t + 250)) for (let n of [...a.internals.handleBounds?.source ?? [], ...a.internals.handleBounds?.target ?? []]) { if (o.nodeId === n.nodeId && o.type === n.type && o.id === n.id) continue; let { x: l, y: s } = n3(a, n, n.position, !0), u = Math.sqrt(Math.pow(l - e.x, 2) + Math.pow(s - e.y, 2)); u > t || (u < i ? (r = [{ ...n, x: l, y: s }], i = u) : u === i && r.push({ ...n, x: l, y: s })) } if (!r.length) return null; if (r.length > 1) { let e = "source" === o.type ? "target" : "source"; return r.find(t => t.type === e) ?? r[0] } return r[0] }(nC(I = nH(e, z), p, !1, [1, 1]), n, s, B), T || (!function e() { if (!c || !z) return; let [t, n] = ng(I, z, _); h({ x: t, y: n }), N = requestAnimationFrame(e) }(), T = !0); let m = of(e, { handle: k, connectionMode: t, fromNodeId: r, fromHandleId: o, fromType: a ? "target" : "source", isValidConnection: x, doc: C, lib: u, flowId: d, nodeLookup: s }); O = m.handleDomNode, R = m.connection, i = !!k, l = m.isValid, f = null, l ? f = !0 : i && !l && (f = !1), L = f; let y = s.get(r), v = y ? n3(y, B, g.Left, !0) : H.from, E = { ...H, from: v, isValid: L, to: m.toHandle && L ? nN({ x: m.toHandle.x, y: m.toHandle.y }, p) : I, toHandle: m.toHandle, toPosition: L && m.toHandle ? m.toHandle.position : nt[B.position], toNode: m.toHandle ? s.get(m.toHandle.nodeId) : null, pointer: I }; b(E), H = E } function Y(e) { if (!("touches" in e) || !(e.touches.length > 0)) { if ($) { (k || O) && R && L && m?.(R); let { inProgress: t, ...n } = H, o = { ...n, toPosition: H.toHandle ? H.toPosition : null }; y?.(e, o), i && v?.(e, o) } f(), cancelAnimationFrame(N), T = !1, L = !1, R = null, O = null, C.removeEventListener("mousemove", X), C.removeEventListener("mouseup", Y), C.removeEventListener("touchmove", X), C.removeEventListener("touchend", Y) } } 0 === M && F(), C.addEventListener("mousemove", X), C.addEventListener("mouseup", Y), C.addEventListener("touchmove", X), C.addEventListener("touchend", Y) }, og = e => ({ x: e.x, y: e.y, zoom: e.k }), om = ({ x: e, y: t, zoom: n }) => tW.translate(e, t).scale(n), oy = (e, t) => e.target.closest(`.${t}`), ox = (e, t) => 2 === t && Array.isArray(e) && e.includes(2), ov = e => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, ob = (e, t = 0, n = ov, o = () => { }) => { let r = "number" == typeof t && t > 0; return r || o(), r ? e.transition().duration(t).ease(n).on("end", o) : e }, ow = e => { let t = e.ctrlKey && nP() ? 10 : 1; return -e.deltaY * (1 === e.deltaMode ? .05 : e.deltaMode ? 1 : .002) * t }; function oS(e) { let t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"); return { isHorizontal: t, isVertical: n, affectsX: e.includes("left"), affectsY: e.includes("top") } } function o_(e, t) { return Math.max(0, t - e) } function oM(e, t) { return Math.max(0, e - t) } function oE(e, t, n) { return Math.max(0, t - e, e - n) } (l = m || (m = {})).Line = "line", l.Handle = "handle"; let ok = { width: 0, height: 0, x: 0, y: 0 }, oC = { ...ok, pointerX: 0, pointerY: 0, aspectRatio: 1 }; var oN = e.i(45854); let oA = { get url() { return `file://${e.P("Desktop/portfolio/Website/Archshield/frontend/node_modules/zustand/esm/vanilla.mjs")}` } }, oj = e => { let t, n = new Set, o = (e, o) => { let r = "function" == typeof e ? e(t) : e; if (!Object.is(r, t)) { let e = t; t = (null != o ? o : "object" != typeof r || null === r) ? r : Object.assign({}, t, r), n.forEach(n => n(t, e)) } }, r = () => t, i = { setState: o, getState: r, getInitialState: () => a, subscribe: e => (n.add(e), () => n.delete(e)), destroy: () => { (oA.env ? oA.env.MODE : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear() } }, a = t = e(o, r, i); return i }, { useDebugValue: oP } = b.default, { useSyncExternalStoreWithSelector: oz } = oN.default, o$ = e => e; function oD(e, t = o$, n) { let o = oz(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n); return oP(o), o } let oI = (e, t) => { let n = e ? oj(e) : oj, o = (e, o = t) => oD(n, e, o); return Object.assign(o, n), o }; function oT(e, t) { if (Object.is(e, t)) return !0; if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1; if (e instanceof Map && t instanceof Map) { if (e.size !== t.size) return !1; for (let [n, o] of e) if (!Object.is(o, t.get(n))) return !1; return !0 } if (e instanceof Set && t instanceof Set) { if (e.size !== t.size) return !1; for (let n of e) if (!t.has(n)) return !1; return !0 } let n = Object.keys(e); if (n.length !== Object.keys(t).length) return !1; for (let o of n) if (!Object.prototype.hasOwnProperty.call(t, o) || !Object.is(e[o], t[o])) return !1; return !0 } e.i(12777); let oR = (0, b.createContext)(null), oL = oR.Provider, oO = "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001"; function oB(e, t) { let n = (0, b.useContext)(oR); if (null === n) throw Error(oO); return oD(n, e, t) } function oV() { let e = (0, b.useContext)(oR); if (null === e) throw Error(oO); return (0, b.useMemo)(() => ({ getState: e.getState, setState: e.setState, subscribe: e.subscribe }), [e]) } let oH = { display: "none" }, oF = { position: "absolute", width: 1, height: 1, margin: -1, border: 0, padding: 0, overflow: "hidden", clip: "rect(0px, 0px, 0px, 0px)", clipPath: "inset(100%)" }, oX = "react-flow__node-desc", oY = "react-flow__edge-desc", oZ = e => e.ariaLiveMessage, oK = e => e.ariaLabelConfig; function oq({ rfId: e }) { let t = oB(oZ); return (0, v.jsx)("div", { id: `react-flow__aria-live-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: oF, children: t }) } function oW({ rfId: e, disableKeyboardA11y: t }) { let n = oB(oK); return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)("div", { id: `${oX}-${e}`, style: oH, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), (0, v.jsx)("div", { id: `${oY}-${e}`, style: oH, children: n["edge.a11yDescription.default"] }), !t && (0, v.jsx)(oq, { rfId: e })] }) } let oU = (0, b.forwardRef)(({ position: e = "top-left", children: t, className: n, style: o, ...r }, i) => { let a = `${e}`.split("-"); return (0, v.jsx)("div", { className: w(["react-flow__panel", n, ...a]), style: o, ref: i, ...r, children: t }) }); function oG({ proOptions: e, position: t = "bottom-right" }) { return e?.hideAttribution ? null : (0, v.jsx)(oU, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: (0, v.jsx)("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) }) } oU.displayName = "Panel"; let oQ = e => { let t = [], n = []; for (let [, n] of e.nodeLookup) n.selected && t.push(n.internals.userNode); for (let [, t] of e.edgeLookup) t.selected && n.push(t); return { selectedNodes: t, selectedEdges: n } }, oJ = e => e.id; function o0(e, t) { return oT(e.selectedNodes.map(oJ), t.selectedNodes.map(oJ)) && oT(e.selectedEdges.map(oJ), t.selectedEdges.map(oJ)) } function o1({ onSelectionChange: e }) { let t = oV(), { selectedNodes: n, selectedEdges: o } = oB(oQ, o0); return (0, b.useEffect)(() => { let r = { nodes: n, edges: o }; e?.(r), t.getState().onSelectionChangeHandlers.forEach(e => e(r)) }, [n, o, e]), null } let o2 = e => !!e.onSelectionChangeHandlers; function o5({ onSelectionChange: e }) { let t = oB(o2); return e || t ? (0, v.jsx)(o1, { onSelectionChange: e }) : null } let o3 = [0, 0], o4 = { x: 0, y: 0, zoom: 1 }, o6 = ["nodes", "edges", "defaultNodes", "defaultEdges", "onConnect", "onConnectStart", "onConnectEnd", "onClickConnectStart", "onClickConnectEnd", "nodesDraggable", "autoPanOnNodeFocus", "nodesConnectable", "nodesFocusable", "edgesFocusable", "edgesReconnectable", "elevateNodesOnSelect", "elevateEdgesOnSelect", "minZoom", "maxZoom", "nodeExtent", "onNodesChange", "onEdgesChange", "elementsSelectable", "connectionMode", "snapGrid", "snapToGrid", "translateExtent", "connectOnClick", "defaultEdgeOptions", "fitView", "fitViewOptions", "onNodesDelete", "onEdgesDelete", "onDelete", "onNodeDrag", "onNodeDragStart", "onNodeDragStop", "onSelectionDrag", "onSelectionDragStart", "onSelectionDragStop", "onMoveStart", "onMove", "onMoveEnd", "noPanClassName", "nodeOrigin", "autoPanOnConnect", "autoPanOnNodeDrag", "onError", "connectionRadius", "isValidConnection", "selectNodesOnDrag", "nodeDragThreshold", "connectionDragThreshold", "onBeforeDelete", "debug", "autoPanSpeed", "ariaLabelConfig", "zIndexMode", "rfId"], o8 = e => ({ setNodes: e.setNodes, setEdges: e.setEdges, setMinZoom: e.setMinZoom, setMaxZoom: e.setMaxZoom, setTranslateExtent: e.setTranslateExtent, setNodeExtent: e.setNodeExtent, reset: e.reset, setDefaultNodesAndEdges: e.setDefaultNodesAndEdges }), o9 = { translateExtent: t8, nodeOrigin: o3, minZoom: .5, maxZoom: 2, elementsSelectable: !0, noPanClassName: "nopan", rfId: "1" }; function o7(e) { let { setNodes: t, setEdges: n, setMinZoom: o, setMaxZoom: r, setTranslateExtent: i, setNodeExtent: a, reset: l, setDefaultNodesAndEdges: s } = oB(o8, oT), u = oV(); (0, b.useEffect)(() => (s(e.defaultNodes, e.defaultEdges), () => { c.current = o9, l() }), []); let c = (0, b.useRef)(o9); return (0, b.useEffect)(() => { for (let l of o6) { let s = e[l]; if (s !== c.current[l] && void 0 !== e[l]) if ("nodes" === l) t(s); else if ("edges" === l) n(s); else if ("minZoom" === l) o(s); else if ("maxZoom" === l) r(s); else if ("translateExtent" === l) i(s); else if ("nodeExtent" === l) a(s); else if ("ariaLabelConfig" === l) u.setState({ ariaLabelConfig: { ...t7, ...s || {} } }); else "fitView" === l ? u.setState({ fitViewQueued: s }) : "fitViewOptions" === l ? u.setState({ fitViewOptions: s }) : u.setState({ [l]: s }) } c.current = e }, o6.map(t => e[t])), null } function re() { return "u" < typeof window || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)") } let rt = "u" > typeof document ? document : null; function rn(e = null, t = { target: rt, actInsideInputWithModifier: !0 }) { let [n, o] = (0, b.useState)(!1), r = (0, b.useRef)(!1), i = (0, b.useRef)(new Set([])), [a, l] = (0, b.useMemo)(() => { if (null !== e) { let t = (Array.isArray(e) ? e : [e]).filter(e => "string" == typeof e).map(e => e.replace("+", "\n").replace("\n\n", "\n+").split("\n")), n = t.reduce((e, t) => e.concat(...t), []); return [t, n] } return [[], []] }, [e]); return (0, b.useEffect)(() => { let n = t?.target ?? rt, s = t?.actInsideInputWithModifier ?? !0; if (null !== e) { let e = e => { if (r.current = e.ctrlKey || e.metaKey || e.shiftKey || e.altKey, (!r.current || r.current && !s) && nV(e)) return !1; let n = rr(e.code, l); if (i.current.add(e[n]), ro(a, i.current, !1)) { let n = e.composedPath?.()?.[0] || e.target, i = n?.nodeName === "BUTTON" || n?.nodeName === "A"; !1 !== t.preventDefault && (r.current || !i) && e.preventDefault(), o(!0) } }, u = e => { let t = rr(e.code, l); ro(a, i.current, !0) ? (o(!1), i.current.clear()) : i.current.delete(e[t]), "Meta" === e.key && i.current.clear(), r.current = !1 }, c = () => { i.current.clear(), o(!1) }; return n?.addEventListener("keydown", e), n?.addEventListener("keyup", u), window.addEventListener("blur", c), window.addEventListener("contextmenu", c), () => { n?.removeEventListener("keydown", e), n?.removeEventListener("keyup", u), window.removeEventListener("blur", c), window.removeEventListener("contextmenu", c) } } }, [e, o]), n } function ro(e, t, n) { return e.filter(e => n || e.length === t.size).some(e => e.every(e => t.has(e))) } function rr(e, t) { return t.includes(e) ? "code" : "key" } function ri(e, t) { let n = [], o = new Map, r = []; for (let t of e) if ("add" === t.type) { r.push(t); continue } else if ("remove" === t.type || "replace" === t.type) o.set(t.id, [t]); else { let e = o.get(t.id); e ? e.push(t) : o.set(t.id, [t]) } for (let e of t) { let t = o.get(e.id); if (!t) { n.push(e); continue } if ("remove" === t[0].type) continue; if ("replace" === t[0].type) { n.push({ ...t[0].item }); continue } let r = { ...e }; for (let e of t) { var i = e, a = r; switch (i.type) { case "select": a.selected = i.selected; break; case "position": void 0 !== i.position && (a.position = i.position), void 0 !== i.dragging && (a.dragging = i.dragging); break; case "dimensions": void 0 !== i.dimensions && (a.measured = { ...i.dimensions }, i.setAttributes && ((!0 === i.setAttributes || "width" === i.setAttributes) && (a.width = i.dimensions.width), (!0 === i.setAttributes || "height" === i.setAttributes) && (a.height = i.dimensions.height))), "boolean" == typeof i.resizing && (a.resizing = i.resizing) } } n.push(r) } return r.length && r.forEach(e => { void 0 !== e.index ? n.splice(e.index, 0, { ...e.item }) : n.push({ ...e.item }) }), n } function ra(e, t) { return { id: e, type: "select", selected: t } } function rl(e, t = new Set, n = !1) { let o = []; for (let [r, i] of e) { let e = t.has(r); (void 0 !== i.selected || e) && i.selected !== e && (n && (i.selected = e), o.push(ra(i.id, e))) } return o } function rs({ items: e = [], lookup: t }) { let n = [], o = new Map(e.map(e => [e.id, e])); for (let [o, r] of e.entries()) { let e = t.get(r.id), i = e?.internals?.userNode ?? e; void 0 !== i && i !== r && n.push({ id: r.id, item: r, type: "replace" }), void 0 === i && n.push({ item: r, type: "add", index: o }) } for (let [e] of t) void 0 === o.get(e) && n.push({ id: e, type: "remove" }); return n } function ru(e) { return { id: e.id, type: "remove" } } let rc = e => "id" in e && "position" in e && !("source" in e) && !("target" in e); function rd(e) { return (0, b.forwardRef)(e) } let rh = "u" > typeof window ? b.useLayoutEffect : b.useEffect; function rf(e) { let [t, n] = (0, b.useState)(BigInt(0)), [o] = (0, b.useState)(() => { var e; let t; return e = () => n(e => e + BigInt(1)), t = [], { get: () => t, reset: () => { t = [] }, push: n => { t.push(n), e() } } }); return rh(() => { let t = o.get(); t.length && (e(t), o.reset()) }, [t]), o } let rp = (0, b.createContext)(null); function rg({ children: e }) { let t = oV(), n = rf((0, b.useCallback)(e => { let { nodes: n = [], setNodes: o, hasDefaultNodes: r, onNodesChange: i, nodeLookup: a, fitViewQueued: l, onNodesChangeMiddlewareMap: s } = t.getState(), u = n; for (let t of e) u = "function" == typeof t ? t(u) : t; let c = rs({ items: u, lookup: a }); for (let e of s.values()) c = e(c); r && o(u), c.length > 0 ? i?.(c) : l && window.requestAnimationFrame(() => { let { fitViewQueued: e, nodes: n, setNodes: o } = t.getState(); e && o(n) }) }, [])), o = rf((0, b.useCallback)(e => { let { edges: n = [], setEdges: o, hasDefaultEdges: r, onEdgesChange: i, edgeLookup: a } = t.getState(), l = n; for (let t of e) l = "function" == typeof t ? t(l) : t; r ? o(l) : i && i(rs({ items: l, lookup: a })) }, [])), r = (0, b.useMemo)(() => ({ nodeQueue: n, edgeQueue: o }), []); return (0, v.jsx)(rp.Provider, { value: r, children: e }) } let rm = e => !!e.panZoom; function ry() { let e, t = (e = oV(), (0, b.useMemo)(() => ({ zoomIn: t => { let { panZoom: n } = e.getState(); return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1) }, zoomOut: t => { let { panZoom: n } = e.getState(); return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1) }, zoomTo: (t, n) => { let { panZoom: o } = e.getState(); return o ? o.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1) }, getZoom: () => e.getState().transform[2], setViewport: async (t, n) => { let { transform: [o, r, i], panZoom: a } = e.getState(); return a ? (await a.setViewport({ x: t.x ?? o, y: t.y ?? r, zoom: t.zoom ?? i }, n), Promise.resolve(!0)) : Promise.resolve(!1) }, getViewport: () => { let [t, n, o] = e.getState().transform; return { x: t, y: n, zoom: o } }, setCenter: async (t, n, o) => e.getState().setCenter(t, n, o), fitBounds: async (t, n) => { let { width: o, height: r, minZoom: i, maxZoom: a, panZoom: l } = e.getState(), s = nj(t, o, r, i, a, n?.padding ?? .1); return l ? (await l.setViewport(s, { duration: n?.duration, ease: n?.ease, interpolate: n?.interpolate }), Promise.resolve(!0)) : Promise.resolve(!1) }, screenToFlowPosition: (t, n = {}) => { let { transform: o, snapGrid: r, snapToGrid: i, domNode: a } = e.getState(); if (!a) return t; let { x: l, y: s } = a.getBoundingClientRect(), u = { x: t.x - l, y: t.y - s }, c = n.snapGrid ?? r; return nC(u, o, n.snapToGrid ?? i, c) }, flowToScreenPosition: t => { let { transform: n, domNode: o } = e.getState(); if (!o) return t; let { x: r, y: i } = o.getBoundingClientRect(), a = nN(t, n); return { x: a.x + r, y: a.y + i } } }), [])), n = oV(), o = function () { let e = (0, b.useContext)(rp); if (!e) throw Error("useBatchContext must be used within a BatchProvider"); return e }(), r = oB(rm), i = (0, b.useMemo)(() => { let e = e => n.getState().nodeLookup.get(e), t = e => { o.nodeQueue.push(e) }, r = e => { o.edgeQueue.push(e) }, i = e => { let { nodeLookup: t, nodeOrigin: o } = n.getState(), r = rc(e) ? e : t.get(e.id), i = r.parentId ? nI(r.position, r.measured, r.parentId, t, o) : r.position; return nv({ ...r, position: i, width: r.measured?.width ?? r.width, height: r.measured?.height ?? r.height }) }, a = (e, n, o = { replace: !1 }) => { t(t => t.map(t => { if (t.id === e) { let e = "function" == typeof n ? n(t) : n; return o.replace && rc(e) ? e : { ...t, ...e } } return t })) }, l = (e, t, n = { replace: !1 }) => { r(o => o.map(o => { if (o.id === e) { let e = "function" == typeof t ? t(o) : t; return n.replace && no(e) ? e : { ...o, ...e } } return o })) }; return { getNodes: () => n.getState().nodes.map(e => ({ ...e })), getNode: t => e(t)?.internals.userNode, getInternalNode: e, getEdges: () => { let { edges: e = [] } = n.getState(); return e.map(e => ({ ...e })) }, getEdge: e => n.getState().edgeLookup.get(e), setNodes: t, setEdges: r, addNodes: e => { let t = Array.isArray(e) ? e : [e]; o.nodeQueue.push(e => [...e, ...t]) }, addEdges: e => { let t = Array.isArray(e) ? e : [e]; o.edgeQueue.push(e => [...e, ...t]) }, toObject: () => { let { nodes: e = [], edges: t = [], transform: o } = n.getState(), [r, i, a] = o; return { nodes: e.map(e => ({ ...e })), edges: t.map(e => ({ ...e })), viewport: { x: r, y: i, zoom: a } } }, deleteElements: async ({ nodes: e = [], edges: t = [] }) => { let { nodes: o, edges: r, onNodesDelete: i, onEdgesDelete: a, triggerNodeChanges: l, triggerEdgeChanges: s, onDelete: u, onBeforeDelete: c } = n.getState(), { nodes: d, edges: h } = await nc({ nodesToRemove: e, edgesToRemove: t, nodes: o, edges: r, onBeforeDelete: c }), f = h.length > 0, p = d.length > 0; if (f) { let e = h.map(ru); a?.(h), s(e) } if (p) { let e = d.map(ru); i?.(d), l(e) } return (p || f) && u?.({ nodes: d, edges: h }), { deletedNodes: d, deletedEdges: h } }, getIntersectingNodes: (e, t = !0, o) => { let r = n_(e), a = r ? e : i(e), l = void 0 !== o; return a ? (o || n.getState().nodes).filter(o => { let i = n.getState().nodeLookup.get(o.id); if (i && !r && (o.id === e.id || !i.internals.positionAbsolute)) return !1; let s = nv(l ? o : i), u = nS(s, a); return t && u > 0 || u >= s.width * s.height || u >= a.width * a.height }) : [] }, isNodeIntersecting: (e, t, n = !0) => { let o = n_(e) ? e : i(e); if (!o) return !1; let r = nS(o, t); return n && r > 0 || r >= t.width * t.height || r >= o.width * o.height }, updateNode: a, updateNodeData: (e, t, n = { replace: !1 }) => { a(e, e => { let o = "function" == typeof t ? t(e) : t; return n.replace ? { ...e, data: o } : { ...e, data: { ...e.data, ...o } } }, n) }, updateEdge: l, updateEdgeData: (e, t, n = { replace: !1 }) => { l(e, e => { let o = "function" == typeof t ? t(e) : t; return n.replace ? { ...e, data: o } : { ...e, data: { ...e.data, ...o } } }, n) }, getNodesBounds: e => { let { nodeLookup: t, nodeOrigin: o } = n.getState(); return ((e, t = { nodeOrigin: [0, 0] }) => 0 === e.length ? { x: 0, y: 0, width: 0, height: 0 } : nx(e.reduce((e, n) => { let o = "string" == typeof n, r = t.nodeLookup || o ? void 0 : n; return t.nodeLookup && (r = o ? t.nodeLookup.get(n) : nr(n) ? n : t.nodeLookup.get(n.id)), nm(e, r ? nb(r, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 }) }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 })))(e, { nodeLookup: t, nodeOrigin: o }) }, getHandleConnections: ({ type: e, id: t, nodeId: o }) => Array.from(n.getState().connectionLookup.get(`${o}-${e}${t ? `-${t}` : ""}`)?.values() ?? []), getNodeConnections: ({ type: e, handleId: t, nodeId: o }) => Array.from(n.getState().connectionLookup.get(`${o}${e ? t ? `-${e}-${t}` : `-${e}` : ""}`)?.values() ?? []), fitView: async e => { let t, r, i = n.getState().fitViewResolver ?? { promise: new Promise((e, n) => { t = e, r = n }), resolve: t, reject: r }; return n.setState({ fitViewQueued: !0, fitViewOptions: e, fitViewResolver: i }), o.nodeQueue.push(e => [...e]), i.promise } } }, []); return (0, b.useMemo)(() => ({ ...i, ...t, viewportInitialized: r }), [r]) } let rx = e => e.selected, rv = "u" > typeof window ? window : void 0, rb = { position: "absolute", width: "100%", height: "100%", top: 0, left: 0 }, rw = e => ({ userSelectionActive: e.userSelectionActive, lib: e.lib, connectionInProgress: e.connection.inProgress }); function rS({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: o = !1, panOnScrollSpeed: r = .5, panOnScrollMode: i = d.Free, zoomOnDoubleClick: a = !0, panOnDrag: l = !0, defaultViewport: s, translateExtent: u, minZoom: c, maxZoom: h, zoomActivationKeyCode: f, preventScrolling: p = !0, children: g, noWheelClassName: m, noPanClassName: y, onViewportChange: x, isControlledViewport: w, paneClickDistance: S, selectionOnDrag: _ }) { let M, E = oV(), k = (0, b.useRef)(null), { userSelectionActive: C, lib: N, connectionInProgress: A } = oB(rw, oT), j = rn(f), P = (0, b.useRef)(); M = oV(), (0, b.useEffect)(() => { let e = () => { if (!k.current || !(k.current.checkVisibility?.() ?? !0)) return !1; let e = nL(k.current); (0 === e.height || 0 === e.width) && M.getState().onError?.("004", "The React Flow parent container needs a width and a height to render the graph."), M.setState({ width: e.width || 500, height: e.height || 500 }) }; if (k.current) { e(), window.addEventListener("resize", e); let t = new ResizeObserver(() => e()); return t.observe(k.current), () => { window.removeEventListener("resize", e), t && k.current && t.unobserve(k.current) } } }, []); let z = (0, b.useCallback)(e => { x?.({ x: e[0], y: e[1], zoom: e[2] }), w || E.setState({ transform: e }) }, [x, w]); return (0, b.useEffect)(() => { if (k.current) { P.current = function ({ domNode: e, minZoom: t, maxZoom: n, translateExtent: o, viewport: r, onPanZoom: i, onPanZoomStart: a, onPanZoomEnd: l, onDraggingChange: s }) { let u = { isZoomingOrPanning: !1, usedRightMouseButton: !1, prevViewport: { x: 0, y: 0, zoom: 0 }, mouseButton: 0, timerId: void 0, panScrollTimeout: void 0, isPanScrolling: !1 }, c = e.getBoundingClientRect(), h = t4().scaleExtent([t, n]).translateExtent(o), f = ef(e).call(h); x({ x: r.x, y: r.y, zoom: nd(r.zoom, t, n) }, [[0, 0], [c.width, c.height]], o); let p = f.on("wheel.zoom"), g = f.on("dblclick.zoom"); function m(e, t) { return f ? new Promise(n => { h?.interpolate(t?.interpolate === "linear" ? t6 : eA).transform(ob(f, t?.duration, t?.ease, () => n(!0)), e) }) : Promise.resolve(!1) } function y() { h.on("zoom", null) } async function x(e, t, n) { let o = om(e), r = h?.constrain()(o, t, n); return r && await m(r), new Promise(e => e(r)) } return h.wheelDelta(ow), { update: function ({ noWheelClassName: e, noPanClassName: t, onPaneContextMenu: n, userSelectionActive: o, panOnScroll: r, panOnDrag: c, panOnScrollMode: m, panOnScrollSpeed: x, preventScrolling: v, zoomOnPinch: b, zoomOnScroll: w, zoomOnDoubleClick: S, zoomActivationKeyPressed: _, lib: M, onTransformChange: E, connectionInProgress: k, paneClickDistance: C, selectionOnDrag: N }) { o && !u.isZoomingOrPanning && y(); let A = r && !_ && !o; h.clickDistance(N ? 1 / 0 : !nM(C) || C < 0 ? 0 : C); let j = A ? function ({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: o, panOnScrollMode: r, panOnScrollSpeed: i, zoomOnPinch: a, onPanZoomStart: l, onPanZoom: s, onPanZoomEnd: u }) { return c => { if (oy(c, t)) return c.ctrlKey && c.preventDefault(), !1; c.preventDefault(), c.stopImmediatePropagation(); let h = n.property("__zoom").k || 1; if (c.ctrlKey && a) { let e = ep(c), t = h * Math.pow(2, ow(c)); o.scaleTo(n, t, e, c); return } let f = 1 === c.deltaMode ? 20 : 1, p = r === d.Vertical ? 0 : c.deltaX * f, g = r === d.Horizontal ? 0 : c.deltaY * f; !nP() && c.shiftKey && r !== d.Vertical && (p = c.deltaY * f, g = 0), o.translateBy(n, -(p / h) * i, -(g / h) * i, { internal: !0 }); let m = og(n.property("__zoom")); clearTimeout(e.panScrollTimeout), e.isPanScrolling ? (s?.(c, m), e.panScrollTimeout = setTimeout(() => { u?.(c, m), e.isPanScrolling = !1 }, 150)) : (e.isPanScrolling = !0, l?.(c, m)) } }({ zoomPanValues: u, noWheelClassName: e, d3Selection: f, d3Zoom: h, panOnScrollMode: m, panOnScrollSpeed: x, zoomOnPinch: b, onPanZoomStart: a, onPanZoom: i, onPanZoomEnd: l }) : function ({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) { return function (o, r) { let i = "wheel" === o.type, a = !t && i && !o.ctrlKey, l = oy(o, e); if (o.ctrlKey && i && l && o.preventDefault(), a || l) return null; o.preventDefault(), n.call(this, o, r) } }({ noWheelClassName: e, preventScrolling: v, d3ZoomHandler: p }); if (f.on("wheel.zoom", j, { passive: !1 }), !o) { let e = function ({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) { return o => { if (o.sourceEvent?.internal) return; let r = og(o.transform); e.mouseButton = o.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = r, o.sourceEvent?.type === "mousedown" && t(!0), n && n?.(o.sourceEvent, r) } }({ zoomPanValues: u, onDraggingChange: s, onPanZoomStart: a }); h.on("start", e); let t = function ({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: o, onPanZoom: r }) { return i => { e.usedRightMouseButton = !!(n && ox(t, e.mouseButton ?? 0)), i.sourceEvent?.sync || o([i.transform.x, i.transform.y, i.transform.k]), r && !i.sourceEvent?.internal && r?.(i.sourceEvent, og(i.transform)) } }({ zoomPanValues: u, panOnDrag: c, onPaneContextMenu: !!n, onPanZoom: i, onTransformChange: E }); h.on("zoom", t); let o = function ({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: o, onPanZoomEnd: r, onPaneContextMenu: i }) { return a => { if (!a.sourceEvent?.internal && (e.isZoomingOrPanning = !1, i && ox(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && a.sourceEvent && i(a.sourceEvent), e.usedRightMouseButton = !1, o(!1), r)) { let t = og(a.transform); e.prevViewport = t, clearTimeout(e.timerId), e.timerId = setTimeout(() => { r?.(a.sourceEvent, t) }, 150 * !!n) } } }({ zoomPanValues: u, panOnDrag: c, panOnScroll: r, onPaneContextMenu: n, onPanZoomEnd: l, onDraggingChange: s }); h.on("end", o) } let P = function ({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: o, panOnScroll: r, zoomOnDoubleClick: i, userSelectionActive: a, noWheelClassName: l, noPanClassName: s, lib: u, connectionInProgress: c }) { return d => { let h = e || t, f = n && d.ctrlKey, p = "wheel" === d.type; if (1 === d.button && "mousedown" === d.type && (oy(d, `${u}-flow__node`) || oy(d, `${u}-flow__edge`))) return !0; if (!o && !h && !r && !i && !n || a || c && !p || oy(d, l) && p || oy(d, s) && (!p || r && p && !e) || !n && d.ctrlKey && p) return !1; if (!n && "touchstart" === d.type && d.touches?.length > 1) return d.preventDefault(), !1; if (!h && !r && !f && p || !o && ("mousedown" === d.type || "touchstart" === d.type) || Array.isArray(o) && !o.includes(d.button) && "mousedown" === d.type) return !1; let g = Array.isArray(o) && o.includes(d.button) || !d.button || d.button <= 1; return (!d.ctrlKey || p) && g } }({ zoomActivationKeyPressed: _, panOnDrag: c, zoomOnScroll: w, panOnScroll: r, zoomOnDoubleClick: S, zoomOnPinch: b, userSelectionActive: o, noPanClassName: t, noWheelClassName: e, lib: M, connectionInProgress: k }); h.filter(P), S ? f.on("dblclick.zoom", g) : f.on("dblclick.zoom", null) }, destroy: y, setViewport: async function e(e, t) { let n = om(e); return await m(n, t), new Promise(e => e(n)) }, setViewportConstrained: x, getViewport: function () { let e = f ? tU(f.node()) : { x: 0, y: 0, k: 1 }; return { x: e.x, y: e.y, zoom: e.k } }, scaleTo: function (e, t) { return f ? new Promise(n => { h?.interpolate(t?.interpolate === "linear" ? t6 : eA).scaleTo(ob(f, t?.duration, t?.ease, () => n(!0)), e) }) : Promise.resolve(!1) }, scaleBy: function (e, t) { return f ? new Promise(n => { h?.interpolate(t?.interpolate === "linear" ? t6 : eA).scaleBy(ob(f, t?.duration, t?.ease, () => n(!0)), e) }) : Promise.resolve(!1) }, setScaleExtent: function (e) { h?.scaleExtent(e) }, setTranslateExtent: function (e) { h?.translateExtent(e) }, syncViewport: function (e) { if (f) { let t = om(e), n = f.property("__zoom"); (n.k !== e.zoom || n.x !== e.x || n.y !== e.y) && h?.transform(f, t, null, { sync: !0 }) } }, setClickDistance: function (e) { let t = !nM(e) || e < 0 ? 0 : e; h?.clickDistance(t) } } }({ domNode: k.current, minZoom: c, maxZoom: h, translateExtent: u, viewport: s, onDraggingChange: e => E.setState({ paneDragging: e }), onPanZoomStart: (e, t) => { let { onViewportChangeStart: n, onMoveStart: o } = E.getState(); o?.(e, t), n?.(t) }, onPanZoom: (e, t) => { let { onViewportChange: n, onMove: o } = E.getState(); o?.(e, t), n?.(t) }, onPanZoomEnd: (e, t) => { let { onViewportChangeEnd: n, onMoveEnd: o } = E.getState(); o?.(e, t), n?.(t) } }); let { x: e, y: t, zoom: n } = P.current.getViewport(); return E.setState({ panZoom: P.current, transform: [e, t, n], domNode: k.current.closest(".react-flow") }), () => { P.current?.destroy() } } }, []), (0, b.useEffect)(() => { P.current?.update({ onPaneContextMenu: e, zoomOnScroll: t, zoomOnPinch: n, panOnScroll: o, panOnScrollSpeed: r, panOnScrollMode: i, zoomOnDoubleClick: a, panOnDrag: l, zoomActivationKeyPressed: j, preventScrolling: p, noPanClassName: y, userSelectionActive: C, noWheelClassName: m, lib: N, onTransformChange: z, connectionInProgress: A, selectionOnDrag: _, paneClickDistance: S }) }, [e, t, n, o, r, i, a, l, j, p, y, C, m, N, z, A, _, S]), (0, v.jsx)("div", { className: "react-flow__renderer", ref: k, style: rb, children: g }) } let r_ = e => ({ userSelectionActive: e.userSelectionActive, userSelectionRect: e.userSelectionRect }); function rM() { let { userSelectionActive: e, userSelectionRect: t } = oB(r_, oT); return e && t ? (0, v.jsx)("div", { className: "react-flow__selection react-flow__container", style: { width: t.width, height: t.height, transform: `translate(${t.x}px, ${t.y}px)` } }) : null } let rE = (e, t) => n => { n.target === t.current && e?.(n) }, rk = e => ({ userSelectionActive: e.userSelectionActive, elementsSelectable: e.elementsSelectable, connectionInProgress: e.connection.inProgress, dragging: e.paneDragging }); function rC({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = h.Full, panOnDrag: o, paneClickDistance: r, selectionOnDrag: i, onSelectionStart: a, onSelectionEnd: l, onPaneClick: s, onPaneContextMenu: u, onPaneScroll: c, onPaneMouseEnter: d, onPaneMouseMove: f, onPaneMouseLeave: p, children: g }) { let m = oV(), { userSelectionActive: y, elementsSelectable: x, dragging: S, connectionInProgress: _ } = oB(rk, oT), M = x && (e || y), E = (0, b.useRef)(null), k = (0, b.useRef)(), C = (0, b.useRef)(new Set), N = (0, b.useRef)(new Set), A = (0, b.useRef)(!1), j = e => { if (A.current || _) { A.current = !1; return } s?.(e), m.getState().resetSelectedElements(), m.setState({ nodesSelectionActive: !1 }) }, P = !0 === o || Array.isArray(o) && o.includes(0); return (0, v.jsxs)("div", { className: w(["react-flow__pane", { draggable: P, dragging: S, selection: e }]), onClick: M ? void 0 : rE(j, E), onContextMenu: rE(e => { Array.isArray(o) && o?.includes(2) ? e.preventDefault() : u?.(e) }, E), onWheel: rE(c ? e => c(e) : void 0, E), onPointerEnter: M ? void 0 : d, onPointerMove: M ? e => { let { userSelectionRect: o, transform: i, nodeLookup: l, edgeLookup: s, connectionLookup: u, triggerNodeChanges: c, triggerEdgeChanges: d, defaultEdgeOptions: f, resetSelectedElements: p } = m.getState(); if (!k.current || !o) return; let { x: g, y: y } = nH(e.nativeEvent, k.current), { startX: x, startY: v } = o; if (!A.current) { if (Math.hypot(g - x, y - v) <= (t ? 0 : r)) return; p(), a?.(e) } A.current = !0; let b = { startX: x, startY: v, x: g < x ? g : x, y: y < v ? y : v, width: Math.abs(g - x), height: Math.abs(y - v) }, w = C.current, S = N.current; C.current = new Set(nl(l, b, i, n === h.Partial, !0).map(e => e.id)), N.current = new Set; let _ = f?.selectable ?? !0; for (let e of C.current) { let t = u.get(e); if (t) for (let { edgeId: e } of t.values()) { let t = s.get(e); t && (t.selectable ?? _) && N.current.add(e) } } nT(w, C.current) || c(rl(l, C.current, !0)), nT(S, N.current) || d(rl(s, N.current)), m.setState({ userSelectionRect: b, userSelectionActive: !0, nodesSelectionActive: !1 }) } : f, onPointerUp: M ? e => { 0 === e.button && (e.target?.releasePointerCapture?.(e.pointerId), !y && e.target === E.current && m.getState().userSelectionRect && j?.(e), m.setState({ userSelectionActive: !1, userSelectionRect: null }), A.current && (l?.(e), m.setState({ nodesSelectionActive: C.current.size > 0 }))) } : void 0, onPointerDownCapture: M ? n => { let { domNode: o } = m.getState(); if (k.current = o?.getBoundingClientRect(), !k.current) return; let r = n.target === E.current; if (!r && n.target.closest(".nokey") || !e || !(i && r || t) || 0 !== n.button || !n.isPrimary) return; n.target?.setPointerCapture?.(n.pointerId), A.current = !1; let { x: a, y: l } = nH(n.nativeEvent, k.current); m.setState({ userSelectionRect: { width: 0, height: 0, startX: a, startY: l, x: a, y: l } }), r || (n.stopPropagation(), n.preventDefault()) } : void 0, onClickCapture: M ? e => { A.current && (e.stopPropagation(), A.current = !1) } : void 0, onPointerLeave: p, ref: E, style: rb, children: [g, (0, v.jsx)(rM, {})] }) } function rN({ id: e, store: t, unselect: n = !1, nodeRef: o }) { let r, { addSelectedNodes: i, unselectNodesAndEdges: a, multiSelectionActive: l, nodeLookup: s, onError: u } = t.getState(), c = s.get(e); c ? (t.setState({ nodesSelectionActive: !1 }), c.selected ? (n || c.selected && l) && (a({ nodes: [c], edges: [] }), requestAnimationFrame(() => o?.current?.blur())) : i([e])) : u?.("012", (r = e, `Node with id "${r}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`)) } function rA({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: o, nodeId: r, isSelectable: i, nodeClickDistance: a }) { let l = oV(), [s, u] = (0, b.useState)(!1), c = (0, b.useRef)(); return (0, b.useEffect)(() => { c.current = function ({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: o, onDragStop: r }) { let i = { x: null, y: null }, a = 0, l = new Map, s = !1, u = { x: 0, y: 0 }, c = null, d = !1, h = null, f = !1, p = !1, g = null; return { update: function ({ noDragClassName: m, handleSelector: y, domNode: x, isSelectable: v, nodeId: b, nodeClickDistance: w = 0 }) { function S({ x: e, y: n }) { let { nodeLookup: r, nodeExtent: a, snapGrid: s, snapToGrid: u, nodeOrigin: c, onNodeDrag: d, onSelectionDrag: h, onError: f, updateNodePositions: m } = t(); i = { x: e, y: n }; let y = !1, x = l.size > 1, v = x && a ? ny(na(l)) : null, w = x && u ? function ({ dragItems: e, snapGrid: t, x: n, y: o }) { let r = e.values().next().value; if (!r) return null; let i = { x: n - r.distance.x, y: o - r.distance.y }, a = nk(i, t); return { x: a.x - i.x, y: a.y - i.y } }({ dragItems: l, snapGrid: s, x: e, y: n }) : null; for (let [t, o] of l) { if (!r.has(t)) continue; let i = { x: e - o.distance.x, y: n - o.distance.y }; u && (i = w ? { x: Math.round(i.x + w.x), y: Math.round(i.y + w.y) } : nk(i, s)); let l = null; if (x && a && !o.extent && v) { let { positionAbsolute: e } = o.internals, t = e.x - v.x + a[0][0], n = e.x + o.measured.width - v.x2 + a[1][0]; l = [[t, e.y - v.y + a[0][1]], [n, e.y + o.measured.height - v.y2 + a[1][1]]] } let { position: d, positionAbsolute: h } = nu({ nodeId: t, nextPosition: i, nodeLookup: r, nodeExtent: l || a, nodeOrigin: c, onError: f }); y = y || o.position.x !== d.x || o.position.y !== d.y, o.position = d, o.internals.positionAbsolute = h } if (p = p || y, y && (m(l, !0), g && (o || d || !b && h))) { let [e, t] = ou({ nodeId: b, dragItems: l, nodeLookup: r }); o?.(g, l, e, t), d?.(g, e, t), b || h?.(g, t) } } async function _() { if (!c) return; let { transform: e, panBy: n, autoPanSpeed: o, autoPanOnNodeDrag: r } = t(); if (!r) { s = !1, cancelAnimationFrame(a); return } let [l, d] = ng(u, c, o); (0 !== l || 0 !== d) && (i.x = (i.x ?? 0) - l / e[2], i.y = (i.y ?? 0) - d / e[2], await n({ x: l, y: d }) && S(i)), a = requestAnimationFrame(_) } function M(o) { let { nodeLookup: r, multiSelectionActive: a, nodesDraggable: s, transform: u, snapGrid: h, snapToGrid: f, selectNodesOnDrag: p, onNodeDragStart: g, onSelectionDragStart: m, unselectNodesAndEdges: y } = t(); d = !0, p && v || a || !b || r.get(b)?.selected || y(), v && p && b && e?.(b); let x = nR(o.sourceEvent, { transform: u, snapGrid: h, snapToGrid: f, containerBounds: c }); if (i = x, (l = function (e, t, n, o) { let r = new Map; for (let [i, a] of e) if ((a.selected || a.id === o) && (!a.parentId || !function e(t, n) { if (!t.parentId) return !1; let o = n.get(t.parentId); return !!o && (!!o.selected || e(o, n)) }(a, e)) && (a.draggable || t && void 0 === a.draggable)) { let t = e.get(i); t && r.set(i, { id: i, position: t.position || { x: 0, y: 0 }, distance: { x: n.x - t.internals.positionAbsolute.x, y: n.y - t.internals.positionAbsolute.y }, extent: t.extent, parentId: t.parentId, origin: t.origin, expandParent: t.expandParent, internals: { positionAbsolute: t.internals.positionAbsolute || { x: 0, y: 0 } }, measured: { width: t.measured.width ?? 0, height: t.measured.height ?? 0 } }) } return r }(r, s, x, b)).size > 0 && (n || g || !b && m)) { let [e, t] = ou({ nodeId: b, dragItems: l, nodeLookup: r }); n?.(o.sourceEvent, l, e, t), g?.(o.sourceEvent, e, t), b || m?.(o.sourceEvent, t) } } h = ef(x); let E = eC().clickDistance(w).on("start", e => { let { domNode: n, nodeDragThreshold: o, transform: r, snapGrid: a, snapToGrid: l } = t(); c = n?.getBoundingClientRect() || null, f = !1, p = !1, g = e.sourceEvent, 0 === o && M(e), i = nR(e.sourceEvent, { transform: r, snapGrid: a, snapToGrid: l, containerBounds: c }), u = nH(e.sourceEvent, c) }).on("drag", e => { let { autoPanOnNodeDrag: n, transform: o, snapGrid: r, snapToGrid: a, nodeDragThreshold: h, nodeLookup: p } = t(), m = nR(e.sourceEvent, { transform: o, snapGrid: r, snapToGrid: a, containerBounds: c }); if (g = e.sourceEvent, ("touchmove" === e.sourceEvent.type && e.sourceEvent.touches.length > 1 || b && !p.has(b)) && (f = !0), !f) { if (!s && n && d && (s = !0, _()), !d) { let t = nH(e.sourceEvent, c), n = t.x - u.x, o = t.y - u.y; Math.sqrt(n * n + o * o) > h && M(e) } (i.x !== m.xSnapped || i.y !== m.ySnapped) && l && d && (u = nH(e.sourceEvent, c), S(m)) } }).on("end", e => { if (d && !f && (s = !1, d = !1, cancelAnimationFrame(a), l.size > 0)) { let { nodeLookup: n, updateNodePositions: o, onNodeDragStop: i, onSelectionDragStop: a } = t(); if (p && (o(l, !1), p = !1), r || i || !b && a) { let [t, o] = ou({ nodeId: b, dragItems: l, nodeLookup: n, dragging: !1 }); r?.(e.sourceEvent, l, t, o), i?.(e.sourceEvent, t, o), b || a?.(e.sourceEvent, o) } } }).filter(e => { let t = e.target; return !e.button && (!m || !os(t, `.${m}`, x)) && (!y || os(t, y, x)) }); h.call(E) }, destroy: function () { h?.on(".drag", null) } } }({ getStoreItems: () => l.getState(), onNodeMouseDown: t => { rN({ id: t, store: l, nodeRef: e }) }, onDragStart: () => { u(!0) }, onDragStop: () => { u(!1) } }) }, []), (0, b.useEffect)(() => { if (t) c.current?.destroy(); else if (e.current) return c.current?.update({ noDragClassName: n, handleSelector: o, domNode: e.current, isSelectable: i, nodeId: r, nodeClickDistance: a }), () => { c.current?.destroy() } }, [n, o, t, i, e, r]), s } function rj() { let e = oV(); return (0, b.useCallback)(t => { let { nodeExtent: n, snapToGrid: o, snapGrid: r, nodesDraggable: i, onError: a, updateNodePositions: l, nodeLookup: s, nodeOrigin: u } = e.getState(), c = new Map, d = e => e.selected && (e.draggable || i && void 0 === e.draggable), h = o ? r[0] : 5, f = o ? r[1] : 5, p = t.direction.x * h * t.factor, g = t.direction.y * f * t.factor; for (let [, e] of s) { if (!d(e)) continue; let t = { x: e.internals.positionAbsolute.x + p, y: e.internals.positionAbsolute.y + g }; o && (t = nk(t, r)); let { position: i, positionAbsolute: l } = nu({ nodeId: e.id, nextPosition: t, nodeLookup: s, nodeExtent: n, nodeOrigin: u, onError: a }); e.position = i, e.internals.positionAbsolute = l, c.set(e.id, e) } l(c) }, []) } let rP = (0, b.createContext)(null), rz = rP.Provider; rP.Consumer; let r$ = () => (0, b.useContext)(rP), rD = e => ({ connectOnClick: e.connectOnClick, noPanClassName: e.noPanClassName, rfId: e.rfId }), rI = (0, b.memo)(rd(function ({ type: e = "source", position: t = g.Top, isValidConnection: n, isConnectable: o = !0, isConnectableStart: r = !0, isConnectableEnd: i = !0, id: a, onConnect: l, children: s, className: u, onMouseDown: d, onTouchStart: h, ...f }, p) { let m = a || null, y = "target" === e, x = oV(), b = r$(), { connectOnClick: S, noPanClassName: _, rfId: M } = oB(rD, oT), { connectingFrom: E, connectingTo: k, clickConnecting: C, isPossibleEndHandle: N, connectionInProcess: A, clickConnectionInProcess: j, valid: P } = oB(t => { let { connectionClickStartHandle: n, connectionMode: o, connection: r } = t, { fromHandle: i, toHandle: a, isValid: l } = r, s = a?.nodeId === b && a?.id === m && a?.type === e; return { connectingFrom: i?.nodeId === b && i?.id === m && i?.type === e, connectingTo: s, clickConnecting: n?.nodeId === b && n?.id === m && n?.type === e, isPossibleEndHandle: o === c.Strict ? i?.type !== e : b !== i?.nodeId || m !== i?.id, connectionInProcess: !!i, clickConnectionInProcess: !!n, valid: s && l } }, oT); b || x.getState().onError?.("010", "Handle: No node id found. Make sure to only use a Handle inside a custom Node."); let z = e => { let { defaultEdgeOptions: t, onConnect: n, hasDefaultEdges: o } = x.getState(), r = { ...t, ...e }; if (o) { let { edges: e, setEdges: t } = x.getState(); t(nU(r, e)) } n?.(r), l?.(r) }, $ = e => { if (!b) return; let t = "clientX" in e.nativeEvent; if (r && (t && 0 === e.button || !t)) { let t = x.getState(); op(e.nativeEvent, { handleDomNode: e.currentTarget, autoPanOnConnect: t.autoPanOnConnect, connectionMode: t.connectionMode, connectionRadius: t.connectionRadius, domNode: t.domNode, nodeLookup: t.nodeLookup, lib: t.lib, isTarget: y, handleId: m, nodeId: b, flowId: t.rfId, panBy: t.panBy, cancelConnection: t.cancelConnection, onConnectStart: t.onConnectStart, onConnectEnd: t.onConnectEnd, updateConnection: t.updateConnection, onConnect: z, isValidConnection: n || t.isValidConnection, getTransform: () => x.getState().transform, getFromHandle: () => x.getState().connection.fromHandle, autoPanSpeed: t.autoPanSpeed, dragThreshold: t.connectionDragThreshold }) } t ? d?.(e) : h?.(e) }; return (0, v.jsx)("div", { "data-handleid": m, "data-nodeid": b, "data-handlepos": t, "data-id": `${M}-${b}-${m}-${e}`, className: w(["react-flow__handle", `react-flow__handle-${t}`, "nodrag", _, u, { source: !y, target: y, connectable: o, connectablestart: r, connectableend: i, clickconnecting: C, connectingfrom: E, connectingto: k, valid: P, connectionindicator: o && (!A || N) && (A || j ? i : r) }]), onMouseDown: $, onTouchStart: $, onClick: S ? t => { let { onClickConnectStart: o, onClickConnectEnd: i, connectionClickStartHandle: a, connectionMode: l, isValidConnection: s, lib: u, rfId: c, nodeLookup: d, connection: h } = x.getState(); if (!b || !a && !r) return; if (!a) { o?.(t.nativeEvent, { nodeId: b, handleId: m, handleType: e }), x.setState({ connectionClickStartHandle: { nodeId: b, type: e, id: m } }); return } let f = nO(t.target), p = n || s, { connection: g, isValid: y } = of(t.nativeEvent, { handle: { nodeId: b, id: m, type: e }, connectionMode: l, fromNodeId: a.nodeId, fromHandleId: a.id || null, fromType: a.type, isValidConnection: p, flowId: c, doc: f, lib: u, nodeLookup: d }); y && g && z(g); let v = structuredClone(h); delete v.inProgress, v.toPosition = v.toHandle ? v.toHandle.position : null, i?.(t, v), x.setState({ connectionClickStartHandle: null }) } : void 0, ref: p, ...f, children: s }) })), rT = { ArrowUp: { x: 0, y: -1 }, ArrowDown: { x: 0, y: 1 }, ArrowLeft: { x: -1, y: 0 }, ArrowRight: { x: 1, y: 0 } }, rR = { input: function ({ data: e, isConnectable: t, sourcePosition: n = g.Bottom }) { return (0, v.jsxs)(v.Fragment, { children: [e?.label, (0, v.jsx)(rI, { type: "source", position: n, isConnectable: t })] }) }, default: function ({ data: e, isConnectable: t, targetPosition: n = g.Top, sourcePosition: o = g.Bottom }) { return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(rI, { type: "target", position: n, isConnectable: t }), e?.label, (0, v.jsx)(rI, { type: "source", position: o, isConnectable: t })] }) }, output: function ({ data: e, isConnectable: t, targetPosition: n = g.Top }) { return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(rI, { type: "target", position: n, isConnectable: t }), e?.label] }) }, group: function () { return null } }, rL = e => { let { width: t, height: n, x: o, y: r } = na(e.nodeLookup, { filter: e => !!e.selected }); return { width: nM(t) ? t : null, height: nM(n) ? n : null, userSelectionActive: e.userSelectionActive, transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${o}px,${r}px)` } }; function rO({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) { let o = oV(), { width: r, height: i, transformString: a, userSelectionActive: l } = oB(rL, oT), s = rj(), u = (0, b.useRef)(null); if ((0, b.useEffect)(() => { n || u.current?.focus({ preventScroll: !0 }) }, [n]), rA({ nodeRef: u }), l || !r || !i) return null; let c = e ? t => { e(t, o.getState().nodes.filter(e => e.selected)) } : void 0; return (0, v.jsx)("div", { className: w(["react-flow__nodesselection", "react-flow__container", t]), style: { transform: a }, children: (0, v.jsx)("div", { ref: u, className: "react-flow__nodesselection-rect", onContextMenu: c, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : e => { Object.prototype.hasOwnProperty.call(rT, e.key) && (e.preventDefault(), s({ direction: rT[e.key], factor: e.shiftKey ? 4 : 1 })) }, style: { width: r, height: i } }) }) } let rB = "u" > typeof window ? window : void 0, rV = e => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive }); function rH({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: r, onPaneContextMenu: i, onPaneScroll: a, paneClickDistance: l, deleteKeyCode: s, selectionKeyCode: u, selectionOnDrag: c, selectionMode: d, onSelectionStart: h, onSelectionEnd: f, multiSelectionKeyCode: p, panActivationKeyCode: g, zoomActivationKeyCode: m, elementsSelectable: y, zoomOnScroll: x, zoomOnPinch: w, panOnScroll: S, panOnScrollSpeed: _, panOnScrollMode: M, zoomOnDoubleClick: E, panOnDrag: k, defaultViewport: C, translateExtent: N, minZoom: A, maxZoom: j, preventScrolling: P, onSelectionContextMenu: z, noWheelClassName: $, noPanClassName: D, disableKeyboardA11y: I, onViewportChange: T, isControlledViewport: R }) { let { nodesSelectionActive: L, userSelectionActive: O } = oB(rV, oT), B = rn(u, { target: rB }), V = rn(g, { target: rB }), H = V || k, F = V || S, X = c && !0 !== H, Y = B || O || X; return !function ({ deleteKeyCode: e, multiSelectionKeyCode: t }) { let n = oV(), { deleteElements: o } = ry(), r = rn(e, { actInsideInputWithModifier: !1 }), i = rn(t, { target: rv }); (0, b.useEffect)(() => { if (r) { let { edges: e, nodes: t } = n.getState(); o({ nodes: t.filter(rx), edges: e.filter(rx) }), n.setState({ nodesSelectionActive: !1 }) } }, [r]), (0, b.useEffect)(() => { n.setState({ multiSelectionActive: i }) }, [i]) }({ deleteKeyCode: s, multiSelectionKeyCode: p }), (0, v.jsx)(rS, { onPaneContextMenu: i, elementsSelectable: y, zoomOnScroll: x, zoomOnPinch: w, panOnScroll: F, panOnScrollSpeed: _, panOnScrollMode: M, zoomOnDoubleClick: E, panOnDrag: !B && H, defaultViewport: C, translateExtent: N, minZoom: A, maxZoom: j, zoomActivationKeyCode: m, preventScrolling: P, noWheelClassName: $, noPanClassName: D, onViewportChange: T, isControlledViewport: R, paneClickDistance: l, selectionOnDrag: X, children: (0, v.jsxs)(rC, { onSelectionStart: h, onSelectionEnd: f, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: r, onPaneContextMenu: i, onPaneScroll: a, panOnDrag: H, isSelecting: !!Y, selectionMode: d, selectionKeyPressed: B, paneClickDistance: l, selectionOnDrag: X, children: [e, L && (0, v.jsx)(rO, { onSelectionContextMenu: z, noPanClassName: D, disableKeyboardA11y: I })] }) }) } rH.displayName = "FlowRenderer"; let rF = (0, b.memo)(rH), rX = e => e.updateNodeInternals; var rY = (0, b.memo)(function ({ id: e, onClick: t, onMouseEnter: n, onMouseMove: o, onMouseLeave: r, onContextMenu: i, onDoubleClick: a, nodesDraggable: l, elementsSelectable: s, nodesConnectable: u, nodesFocusable: c, resizeObserver: d, noDragClassName: h, noPanClassName: f, disableKeyboardA11y: p, rfId: g, nodeTypes: m, nodeClickDistance: y, onError: x }) { let S, { node: _, internals: M, isParent: E } = oB(t => { let n = t.nodeLookup.get(e), o = t.parentLookup.has(e); return { node: n, internals: n.internals, isParent: o } }, oT), k = _.type || "default", C = m?.[k] || rR[k]; void 0 === C && (x?.("003", (S = k, `Node type "${S}" not found. Using fallback type "default".`)), k = "default", C = m?.default || rR.default); let N = !!(_.draggable || l && void 0 === _.draggable), A = !!(_.selectable || s && void 0 === _.selectable), j = !!(_.connectable || u && void 0 === _.connectable), P = !!(_.focusable || c && void 0 === _.focusable), z = oV(), $ = nD(_), D = function ({ node: e, nodeType: t, hasDimensions: n, resizeObserver: o }) { let r = oV(), i = (0, b.useRef)(null), a = (0, b.useRef)(null), l = (0, b.useRef)(e.sourcePosition), s = (0, b.useRef)(e.targetPosition), u = (0, b.useRef)(t), c = n && !!e.internals.handleBounds; return (0, b.useEffect)(() => { !i.current || e.hidden || c && a.current === i.current || (a.current && o?.unobserve(a.current), o?.observe(i.current), a.current = i.current) }, [c, e.hidden]), (0, b.useEffect)(() => () => { a.current && (o?.unobserve(a.current), a.current = null) }, []), (0, b.useEffect)(() => { if (i.current) { let n = u.current !== t, o = l.current !== e.sourcePosition, a = s.current !== e.targetPosition; (n || o || a) && (u.current = t, l.current = e.sourcePosition, s.current = e.targetPosition, r.getState().updateNodeInternals(new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]]))) } }, [e.id, t, e.sourcePosition, e.targetPosition]), i }({ node: _, nodeType: k, hasDimensions: $, resizeObserver: d }), I = rA({ nodeRef: D, disabled: _.hidden || !N, noDragClassName: h, handleSelector: _.dragHandle, nodeId: e, isSelectable: A, nodeClickDistance: y }), T = rj(); if (_.hidden) return null; let R = n$(_), L = void 0 === _.internals.handleBounds ? { width: _.width ?? _.initialWidth ?? _.style?.width, height: _.height ?? _.initialHeight ?? _.style?.height } : { width: _.width ?? _.style?.width, height: _.height ?? _.style?.height }, O = A || N || t || n || o || r, B = n ? e => n(e, { ...M.userNode }) : void 0, V = o ? e => o(e, { ...M.userNode }) : void 0, H = r ? e => r(e, { ...M.userNode }) : void 0, F = i ? e => i(e, { ...M.userNode }) : void 0, X = a ? e => a(e, { ...M.userNode }) : void 0; return (0, v.jsx)("div", { className: w(["react-flow__node", `react-flow__node-${k}`, { [f]: N }, _.className, { selected: _.selected, selectable: A, parent: E, draggable: N, dragging: I }]), ref: D, style: { zIndex: M.z, transform: `translate(${M.positionAbsolute.x}px,${M.positionAbsolute.y}px)`, pointerEvents: O ? "all" : "none", visibility: $ ? "visible" : "hidden", ..._.style, ...L }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: B, onMouseMove: V, onMouseLeave: H, onContextMenu: F, onClick: n => { let { selectNodesOnDrag: o, nodeDragThreshold: r } = z.getState(); A && (!o || !N || r > 0) && rN({ id: e, store: z, nodeRef: D }), t && t(n, { ...M.userNode }) }, onDoubleClick: X, onKeyDown: P ? t => { if (!nV(t.nativeEvent) && !p) { if (t9.includes(t.key) && A) rN({ id: e, store: z, unselect: "Escape" === t.key, nodeRef: D }); else if (N && _.selected && Object.prototype.hasOwnProperty.call(rT, t.key)) { t.preventDefault(); let { ariaLabelConfig: e } = z.getState(); z.setState({ ariaLiveMessage: e["node.a11yDescription.ariaLiveMessage"]({ direction: t.key.replace("Arrow", "").toLowerCase(), x: ~~M.positionAbsolute.x, y: ~~M.positionAbsolute.y }) }), T({ direction: rT[t.key], factor: t.shiftKey ? 4 : 1 }) } } } : void 0, tabIndex: P ? 0 : void 0, onFocus: P ? () => { if (p || !D.current?.matches(":focus-visible")) return; let { transform: t, width: n, height: o, autoPanOnNodeFocus: r, setCenter: i } = z.getState(); !r || nl(new Map([[e, _]]), { x: 0, y: 0, width: n, height: o }, t, !0).length > 0 || i(_.position.x + R.width / 2, _.position.y + R.height / 2, { zoom: t[2] }) } : void 0, role: _.ariaRole ?? (P ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": p ? void 0 : `${oX}-${g}`, "aria-label": _.ariaLabel, ..._.domAttributes, children: (0, v.jsx)(rz, { value: e, children: (0, v.jsx)(C, { id: e, data: _.data, type: k, positionAbsoluteX: M.positionAbsolute.x, positionAbsoluteY: M.positionAbsolute.y, selected: _.selected ?? !1, selectable: A, draggable: N, deletable: _.deletable ?? !0, isConnectable: j, sourcePosition: _.sourcePosition, targetPosition: _.targetPosition, dragging: I, dragHandle: _.dragHandle, zIndex: M.z, parentId: _.parentId, ...R }) }) }) }); let rZ = e => ({ nodesDraggable: e.nodesDraggable, nodesConnectable: e.nodesConnectable, nodesFocusable: e.nodesFocusable, elementsSelectable: e.elementsSelectable, onError: e.onError }); function rK(e) { var t; let { nodesDraggable: n, nodesConnectable: o, nodesFocusable: r, elementsSelectable: i, onError: a } = oB(rZ, oT), l = (t = e.onlyRenderVisibleElements, oB((0, b.useCallback)(e => t ? nl(e.nodeLookup, { x: 0, y: 0, width: e.width, height: e.height }, e.transform, !0).map(e => e.id) : Array.from(e.nodeLookup.keys()), [t]), oT)), s = function () { let e = oB(rX), [t] = (0, b.useState)(() => "u" < typeof ResizeObserver ? null : new ResizeObserver(t => { let n = new Map; t.forEach(e => { let t = e.target.getAttribute("data-id"); n.set(t, { id: t, nodeElement: e.target, force: !0 }) }), e(n) })); return (0, b.useEffect)(() => () => { t?.disconnect() }, [t]), t }(); return (0, v.jsx)("div", { className: "react-flow__nodes", style: rb, children: l.map(t => (0, v.jsx)(rY, { id: t, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: s, nodesDraggable: n, nodesConnectable: o, nodesFocusable: r, elementsSelectable: i, nodeClickDistance: e.nodeClickDistance, onError: a }, t)) }) } rK.displayName = "NodeRenderer"; let rq = (0, b.memo)(rK), rW = { [p.Arrow]: ({ color: e = "none", strokeWidth: t = 1 }) => { let n = { strokeWidth: t, ...e && { stroke: e } }; return (0, v.jsx)("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" }) }, [p.ArrowClosed]: ({ color: e = "none", strokeWidth: t = 1 }) => { let n = { strokeWidth: t, ...e && { stroke: e, fill: e } }; return (0, v.jsx)("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }) } }, rU = ({ id: e, type: t, color: n, width: o = 12.5, height: r = 12.5, markerUnits: i = "strokeWidth", strokeWidth: a, orient: l = "auto-start-reverse" }) => { let s, u = (s = oV(), (0, b.useMemo)(() => { let e; return Object.prototype.hasOwnProperty.call(rW, t) ? rW[t] : (s.getState().onError?.("009", (e = t, `Marker type "${e}" doesn't exist.`)), null) }, [t])); return u ? (0, v.jsx)("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${o}`, markerHeight: `${r}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: l, refX: "0", refY: "0", children: (0, v.jsx)(u, { color: n, strokeWidth: a }) }) : null }, rG = ({ defaultColor: e, rfId: t }) => { let n = oB(e => e.edges), o = oB(e => e.defaultEdgeOptions), r = (0, b.useMemo)(() => (function (e, { id: t, defaultColor: n, defaultMarkerStart: o, defaultMarkerEnd: r }) { let i = new Set; return e.reduce((e, a) => ([a.markerStart || o, a.markerEnd || r].forEach(o => { if (o && "object" == typeof o) { let r = n6(o, t); i.has(r) || (e.push({ id: r, color: o.color || n, ...o }), i.add(r)) } }), e), []).sort((e, t) => e.id.localeCompare(t.id)) })(n, { id: t, defaultColor: e, defaultMarkerStart: o?.markerStart, defaultMarkerEnd: o?.markerEnd }), [n, o, t, e]); return r.length ? (0, v.jsx)("svg", { className: "react-flow__marker", "aria-hidden": "true", children: (0, v.jsx)("defs", { children: r.map(e => (0, v.jsx)(rU, { id: e.id, type: e.type, color: e.color, width: e.width, height: e.height, markerUnits: e.markerUnits, strokeWidth: e.strokeWidth, orient: e.orient }, e.id)) }) }) : null }; rG.displayName = "MarkerDefinitions"; var rQ = (0, b.memo)(rG); function rJ({ x: e, y: t, label: n, labelStyle: o, labelShowBg: r = !0, labelBgStyle: i, labelBgPadding: a = [2, 4], labelBgBorderRadius: l = 2, children: s, className: u, ...c }) { let [d, h] = (0, b.useState)({ x: 1, y: 0, width: 0, height: 0 }), f = w(["react-flow__edge-textwrapper", u]), p = (0, b.useRef)(null); return ((0, b.useEffect)(() => { if (p.current) { let e = p.current.getBBox(); h({ x: e.x, y: e.y, width: e.width, height: e.height }) } }, [n]), n) ? (0, v.jsxs)("g", { transform: `translate(${e - d.width / 2} ${t - d.height / 2})`, className: f, visibility: d.width ? "visible" : "hidden", ...c, children: [r && (0, v.jsx)("rect", { width: d.width + 2 * a[0], x: -a[0], y: -a[1], height: d.height + 2 * a[1], className: "react-flow__edge-textbg", style: i, rx: l, ry: l }), (0, v.jsx)("text", { className: "react-flow__edge-text", y: d.height / 2, dy: "0.3em", ref: p, style: o, children: n }), s] }) : null } rJ.displayName = "EdgeText"; let r0 = (0, b.memo)(rJ); function r1({ path: e, labelX: t, labelY: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: s, interactionWidth: u = 20, ...c }) { return (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)("path", { ...c, d: e, fill: "none", className: w(["react-flow__edge-path", c.className]) }), u ? (0, v.jsx)("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: u, className: "react-flow__edge-interaction" }) : null, o && nM(t) && nM(n) ? (0, v.jsx)(r0, { x: t, y: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: s }) : null] }) } function r2({ pos: e, x1: t, y1: n, x2: o, y2: r }) { return e === g.Left || e === g.Right ? [.5 * (t + o), n] : [t, .5 * (n + r)] } function r5({ sourceX: e, sourceY: t, sourcePosition: n = g.Bottom, targetX: o, targetY: r, targetPosition: i = g.Top }) { let [a, l] = r2({ pos: n, x1: e, y1: t, x2: o, y2: r }), [s, u] = r2({ pos: i, x1: o, y1: r, x2: e, y2: t }), [c, d, h, f] = nX({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: a, sourceControlY: l, targetControlX: s, targetControlY: u }); return [`M${e},${t} C${a},${l} ${s},${u} ${o},${r}`, c, d, h, f] } function r3(e) { return (0, b.memo)(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: a, targetPosition: l, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: f, style: p, markerEnd: g, markerStart: m, interactionWidth: y }) => { let [x, b, w] = r5({ sourceX: n, sourceY: o, sourcePosition: a, targetX: r, targetY: i, targetPosition: l }), S = e.isInternal ? void 0 : t; return (0, v.jsx)(r1, { id: S, path: x, labelX: b, labelY: w, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: f, style: p, markerEnd: g, markerStart: m, interactionWidth: y }) }) } let r4 = r3({ isInternal: !1 }), r6 = r3({ isInternal: !0 }); function r8(e) { return (0, b.memo)(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: a, labelStyle: l, labelShowBg: s, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: h, sourcePosition: f = g.Bottom, targetPosition: p = g.Top, markerEnd: m, markerStart: y, pathOptions: x, interactionWidth: b }) => { let [w, S, _] = n1({ sourceX: n, sourceY: o, sourcePosition: f, targetX: r, targetY: i, targetPosition: p, borderRadius: x?.borderRadius, offset: x?.offset, stepPosition: x?.stepPosition }), M = e.isInternal ? void 0 : t; return (0, v.jsx)(r1, { id: M, path: w, labelX: S, labelY: _, label: a, labelStyle: l, labelShowBg: s, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: h, markerEnd: m, markerStart: y, interactionWidth: b }) }) } r4.displayName = "SimpleBezierEdge", r6.displayName = "SimpleBezierEdgeInternal"; let r9 = r8({ isInternal: !1 }), r7 = r8({ isInternal: !0 }); function ie(e) { return (0, b.memo)(({ id: t, ...n }) => { let o = e.isInternal ? void 0 : t; return (0, v.jsx)(r9, { ...n, id: o, pathOptions: (0, b.useMemo)(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) }) }) } r9.displayName = "SmoothStepEdge", r7.displayName = "SmoothStepEdgeInternal"; let it = ie({ isInternal: !1 }), io = ie({ isInternal: !0 }); function ir(e) { return (0, b.memo)(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: a, labelStyle: l, labelShowBg: s, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: h, markerEnd: f, markerStart: p, interactionWidth: g }) => { let [m, y, x] = nG({ sourceX: n, sourceY: o, targetX: r, targetY: i }), b = e.isInternal ? void 0 : t; return (0, v.jsx)(r1, { id: b, path: m, labelX: y, labelY: x, label: a, labelStyle: l, labelShowBg: s, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: h, markerEnd: f, markerStart: p, interactionWidth: g }) }) } it.displayName = "StepEdge", io.displayName = "StepEdgeInternal"; let ii = ir({ isInternal: !1 }), ia = ir({ isInternal: !0 }); function il(e) { return (0, b.memo)(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: a = g.Bottom, targetPosition: l = g.Top, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: f, style: p, markerEnd: m, markerStart: y, pathOptions: x, interactionWidth: b }) => { let [w, S, _] = nK({ sourceX: n, sourceY: o, sourcePosition: a, targetX: r, targetY: i, targetPosition: l, curvature: x?.curvature }), M = e.isInternal ? void 0 : t; return (0, v.jsx)(r1, { id: M, path: w, labelX: S, labelY: _, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: f, style: p, markerEnd: m, markerStart: y, interactionWidth: b }) }) } ii.displayName = "StraightEdge", ia.displayName = "StraightEdgeInternal"; let is = il({ isInternal: !1 }), iu = il({ isInternal: !0 }); is.displayName = "BezierEdge", iu.displayName = "BezierEdgeInternal"; let ic = { default: iu, straight: ia, step: io, smoothstep: r7, simplebezier: r6 }, id = { sourceX: null, sourceY: null, targetX: null, targetY: null, sourcePosition: null, targetPosition: null }, ih = "react-flow__edgeupdater"; function ip({ position: e, centerX: t, centerY: n, radius: o = 10, onMouseDown: r, onMouseEnter: i, onMouseOut: a, type: l }) { return (0, v.jsx)("circle", { onMouseDown: r, onMouseEnter: i, onMouseOut: a, className: w([ih, `${ih}-${l}`]), cx: e === g.Left ? t - o : e === g.Right ? t + o : t, cy: e === g.Top ? n - o : e === g.Bottom ? n + o : n, r: o, stroke: "transparent", fill: "transparent" }) } function ig({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: o, sourceY: r, targetX: i, targetY: a, sourcePosition: l, targetPosition: s, onReconnect: u, onReconnectStart: c, onReconnectEnd: d, setReconnecting: h, setUpdateHover: f }) { let p = oV(), g = (e, t) => { if (0 !== e.button) return; let { autoPanOnConnect: o, domNode: r, isValidConnection: i, connectionMode: a, connectionRadius: l, lib: s, onConnectStart: f, onConnectEnd: g, cancelConnection: m, nodeLookup: y, rfId: x, panBy: v, updateConnection: b } = p.getState(), w = "target" === t.type; op(e.nativeEvent, { autoPanOnConnect: o, connectionMode: a, connectionRadius: l, domNode: r, handleId: t.id, nodeId: t.nodeId, nodeLookup: y, isTarget: w, edgeUpdaterType: t.type, lib: s, flowId: x, cancelConnection: m, panBy: v, isValidConnection: i, onConnect: e => u?.(n, e), onConnectStart: (o, r) => { h(!0), c?.(e, n, t.type), f?.(o, r) }, onConnectEnd: g, onReconnectEnd: (e, o) => { h(!1), d?.(e, n, t.type, o) }, updateConnection: b, getTransform: () => p.getState().transform, getFromHandle: () => p.getState().connection.fromHandle, dragThreshold: p.getState().connectionDragThreshold, handleDomNode: e.currentTarget }) }, m = () => f(!0), y = () => f(!1); return (0, v.jsxs)(v.Fragment, { children: [(!0 === e || "source" === e) && (0, v.jsx)(ip, { position: l, centerX: o, centerY: r, radius: t, onMouseDown: e => g(e, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), onMouseEnter: m, onMouseOut: y, type: "source" }), (!0 === e || "target" === e) && (0, v.jsx)(ip, { position: s, centerX: i, centerY: a, radius: t, onMouseDown: e => g(e, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), onMouseEnter: m, onMouseOut: y, type: "target" })] }) } var im = (0, b.memo)(function ({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: o, onClick: r, onDoubleClick: i, onContextMenu: a, onMouseEnter: l, onMouseMove: s, onMouseLeave: u, reconnectRadius: d, onReconnect: h, onReconnectStart: f, onReconnectEnd: p, rfId: m, edgeTypes: y, noPanClassName: x, onError: S, disableKeyboardA11y: _ }) { let M, E = oB(t => t.edgeLookup.get(e)), k = oB(e => e.defaultEdgeOptions), C = (E = k ? { ...k, ...E } : E).type || "default", N = y?.[C] || ic[C]; void 0 === N && (S?.("011", (M = C, `Edge type "${M}" not found. Using fallback type "default".`)), C = "default", N = y?.default || ic.default); let A = !!(E.focusable || t && void 0 === E.focusable), j = void 0 !== h && (E.reconnectable || n && void 0 === E.reconnectable), P = !!(E.selectable || o && void 0 === E.selectable), z = (0, b.useRef)(null), [$, D] = (0, b.useState)(!1), [I, T] = (0, b.useState)(!1), R = oV(), { zIndex: L, sourceX: O, sourceY: B, targetX: V, targetY: H, sourcePosition: F, targetPosition: X } = oB((0, b.useCallback)(t => { let n = t.nodeLookup.get(E.source), o = t.nodeLookup.get(E.target); if (!n || !o) return { zIndex: E.zIndex, ...id }; let r = function (e) { let { sourceNode: t, targetNode: n } = e; if (!n2(t) || !n2(n)) return null; let o = t.internals.handleBounds || n5(t.handles), r = n.internals.handleBounds || n5(n.handles), i = n4(o?.source ?? [], e.sourceHandle), a = n4(e.connectionMode === c.Strict ? r?.target ?? [] : (r?.target ?? []).concat(r?.source ?? []), e.targetHandle); if (!i || !a) return e.onError?.("008", ((e, { id: t, sourceHandle: n, targetHandle: o }) => `Couldn't create edge for ${e} handle id: "${"source" === e ? n : o}", edge id: ${t}.`)(!i ? "source" : "target", { id: e.id, sourceHandle: e.sourceHandle, targetHandle: e.targetHandle })), null; let l = i?.position || g.Bottom, s = a?.position || g.Top, u = n3(t, i, l), d = n3(n, a, s); return { sourceX: u.x, sourceY: u.y, targetX: d.x, targetY: d.y, sourcePosition: l, targetPosition: s } }({ id: e, sourceNode: n, targetNode: o, sourceHandle: E.sourceHandle || null, targetHandle: E.targetHandle || null, connectionMode: t.connectionMode, onError: S }); return { zIndex: function ({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: o = 0, elevateOnSelect: r = !1, zIndexMode: i = "basic" }) { if ("manual" === i) return o; let a = Math.max(e.parentId || r && e.selected ? e.internals.z : 0, t.parentId || r && t.selected ? t.internals.z : 0); return (r && n ? o + 1e3 : o) + a }({ selected: E.selected, zIndex: E.zIndex, sourceNode: n, targetNode: o, elevateOnSelect: t.elevateEdgesOnSelect, zIndexMode: t.zIndexMode }), ...r || id } }, [E.source, E.target, E.sourceHandle, E.targetHandle, E.selected, E.zIndex]), oT), Y = (0, b.useMemo)(() => E.markerStart ? `url('#${n6(E.markerStart, m)}')` : void 0, [E.markerStart, m]), Z = (0, b.useMemo)(() => E.markerEnd ? `url('#${n6(E.markerEnd, m)}')` : void 0, [E.markerEnd, m]); if (E.hidden || null === O || null === B || null === V || null === H) return null; let K = i ? e => { i(e, { ...E }) } : void 0, q = a ? e => { a(e, { ...E }) } : void 0, W = l ? e => { l(e, { ...E }) } : void 0, U = s ? e => { s(e, { ...E }) } : void 0, G = u ? e => { u(e, { ...E }) } : void 0; return (0, v.jsx)("svg", { style: { zIndex: L }, children: (0, v.jsxs)("g", { className: w(["react-flow__edge", `react-flow__edge-${C}`, E.className, x, { selected: E.selected, animated: E.animated, inactive: !P && !r, updating: $, selectable: P }]), onClick: t => { let { addSelectedEdges: n, unselectNodesAndEdges: o, multiSelectionActive: i } = R.getState(); P && (R.setState({ nodesSelectionActive: !1 }), E.selected && i ? (o({ nodes: [], edges: [E] }), z.current?.blur()) : n([e])), r && r(t, E) }, onDoubleClick: K, onContextMenu: q, onMouseEnter: W, onMouseMove: U, onMouseLeave: G, onKeyDown: A ? t => { if (!_ && t9.includes(t.key) && P) { let { unselectNodesAndEdges: n, addSelectedEdges: o } = R.getState(); "Escape" === t.key ? (z.current?.blur(), n({ edges: [E] })) : o([e]) } } : void 0, tabIndex: A ? 0 : void 0, role: E.ariaRole ?? (A ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": null === E.ariaLabel ? void 0 : E.ariaLabel || `Edge from ${E.source} to ${E.target}`, "aria-describedby": A ? `${oY}-${m}` : void 0, ref: z, ...E.domAttributes, children: [!I && (0, v.jsx)(N, { id: e, source: E.source, target: E.target, type: E.type, selected: E.selected, animated: E.animated, selectable: P, deletable: E.deletable ?? !0, label: E.label, labelStyle: E.labelStyle, labelShowBg: E.labelShowBg, labelBgStyle: E.labelBgStyle, labelBgPadding: E.labelBgPadding, labelBgBorderRadius: E.labelBgBorderRadius, sourceX: O, sourceY: B, targetX: V, targetY: H, sourcePosition: F, targetPosition: X, data: E.data, style: E.style, sourceHandleId: E.sourceHandle, targetHandleId: E.targetHandle, markerStart: Y, markerEnd: Z, pathOptions: "pathOptions" in E ? E.pathOptions : void 0, interactionWidth: E.interactionWidth }), j && (0, v.jsx)(ig, { edge: E, isReconnectable: j, reconnectRadius: d, onReconnect: h, onReconnectStart: f, onReconnectEnd: p, sourceX: O, sourceY: B, targetX: V, targetY: H, sourcePosition: F, targetPosition: X, setUpdateHover: D, setReconnecting: T })] }) }) }); let iy = e => ({ edgesFocusable: e.edgesFocusable, edgesReconnectable: e.edgesReconnectable, elementsSelectable: e.elementsSelectable, connectionMode: e.connectionMode, onError: e.onError }); function ix({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: o, noPanClassName: r, onReconnect: i, onEdgeContextMenu: a, onEdgeMouseEnter: l, onEdgeMouseMove: s, onEdgeMouseLeave: u, onEdgeClick: c, reconnectRadius: d, onEdgeDoubleClick: h, onReconnectStart: f, onReconnectEnd: p, disableKeyboardA11y: g }) { let { edgesFocusable: m, edgesReconnectable: y, elementsSelectable: x, onError: w } = oB(iy, oT), S = oB((0, b.useCallback)(e => { if (!t) return e.edges.map(e => e.id); let n = []; if (e.width && e.height) for (let t of e.edges) { let o = e.nodeLookup.get(t.source), r = e.nodeLookup.get(t.target); o && r && function ({ sourceNode: e, targetNode: t, width: n, height: o, transform: r }) { let i = nm(nb(e), nb(t)); return i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1), nS({ x: -r[0] / r[2], y: -r[1] / r[2], width: n / r[2], height: o / r[2] }, nx(i)) > 0 }({ sourceNode: o, targetNode: r, width: e.width, height: e.height, transform: e.transform }) && n.push(t.id) } return n }, [t]), oT); return (0, v.jsxs)("div", { className: "react-flow__edges", children: [(0, v.jsx)(rQ, { defaultColor: e, rfId: n }), S.map(e => (0, v.jsx)(im, { id: e, edgesFocusable: m, edgesReconnectable: y, elementsSelectable: x, noPanClassName: r, onReconnect: i, onContextMenu: a, onMouseEnter: l, onMouseMove: s, onMouseLeave: u, onClick: c, reconnectRadius: d, onDoubleClick: h, onReconnectStart: f, onReconnectEnd: p, rfId: n, onError: w, edgeTypes: o, disableKeyboardA11y: g }, e))] }) } ix.displayName = "EdgeRenderer"; let iv = (0, b.memo)(ix), ib = e => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`; function iw({ children: e }) { let t = oB(ib); return (0, v.jsx)("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e }) } let iS = e => e.panZoom?.syncViewport; function i_(e) { return e.connection.inProgress ? { ...e.connection, to: nC(e.connection.to, e.transform) } : { ...e.connection } } let iM = e => ({ nodesConnectable: e.nodesConnectable, isValid: e.connection.isValid, inProgress: e.connection.inProgress, width: e.width, height: e.height }); function iE({ containerStyle: e, style: t, type: n, component: o }) { let { nodesConnectable: r, width: i, height: a, isValid: l, inProgress: s } = oB(iM, oT); return i && r && s ? (0, v.jsx)("svg", { style: e, width: i, height: a, className: "react-flow__connectionline react-flow__container", children: (0, v.jsx)("g", { className: w(["react-flow__connection", nn(l)]), children: (0, v.jsx)(ik, { style: t, type: n, CustomComponent: o, isValid: l }) }) }) : null } let ik = ({ style: e, type: t = f.Bezier, CustomComponent: n, isValid: o }) => { let { inProgress: r, from: i, fromNode: a, fromHandle: l, fromPosition: s, to: u, toNode: c, toHandle: d, toPosition: h, pointer: p } = oB(i_, oT); if (!r) return; if (n) return (0, v.jsx)(n, { connectionLineType: t, connectionLineStyle: e, fromNode: a, fromHandle: l, fromX: i.x, fromY: i.y, toX: u.x, toY: u.y, fromPosition: s, toPosition: h, connectionStatus: nn(o), toNode: c, toHandle: d, pointer: p }); let g = "", m = { sourceX: i.x, sourceY: i.y, sourcePosition: s, targetX: u.x, targetY: u.y, targetPosition: h }; switch (t) { case f.Bezier: [g] = nK(m); break; case f.SimpleBezier: [g] = r5(m); break; case f.Step: [g] = n1({ ...m, borderRadius: 0 }); break; case f.SmoothStep: [g] = n1(m); break; default: [g] = nG(m) }return (0, v.jsx)("path", { d: g, fill: "none", className: "react-flow__connection-path", style: e }) }; ik.displayName = "ConnectionLine"; let iC = {}; function iN(e = iC) { (0, b.useRef)(e), oV(), (0, b.useEffect)(() => { }, [e]) } function iA({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: o, onEdgeClick: r, onNodeDoubleClick: i, onEdgeDoubleClick: a, onNodeMouseEnter: l, onNodeMouseMove: s, onNodeMouseLeave: u, onNodeContextMenu: c, onSelectionContextMenu: d, onSelectionStart: h, onSelectionEnd: f, connectionLineType: p, connectionLineStyle: g, connectionLineComponent: m, connectionLineContainerStyle: y, selectionKeyCode: x, selectionOnDrag: w, selectionMode: S, multiSelectionKeyCode: _, panActivationKeyCode: M, zoomActivationKeyCode: E, deleteKeyCode: k, onlyRenderVisibleElements: C, elementsSelectable: N, defaultViewport: A, translateExtent: j, minZoom: P, maxZoom: z, preventScrolling: $, defaultMarkerColor: D, zoomOnScroll: I, zoomOnPinch: T, panOnScroll: R, panOnScrollSpeed: L, panOnScrollMode: O, zoomOnDoubleClick: B, panOnDrag: V, onPaneClick: H, onPaneMouseEnter: F, onPaneMouseMove: X, onPaneMouseLeave: Y, onPaneScroll: Z, onPaneContextMenu: K, paneClickDistance: q, nodeClickDistance: W, onEdgeContextMenu: U, onEdgeMouseEnter: G, onEdgeMouseMove: Q, onEdgeMouseLeave: J, reconnectRadius: ee, onReconnect: et, onReconnectStart: en, onReconnectEnd: eo, noDragClassName: er, noWheelClassName: ei, noPanClassName: ea, disableKeyboardA11y: el, nodeExtent: es, rfId: eu, viewport: ec, onViewportChange: ed }) { let eh, ef, ep, eg; return iN(e), iN(t), oV(), (0, b.useRef)(!1), (0, b.useEffect)(() => { }, []), eh = ry(), ef = (0, b.useRef)(!1), (0, b.useEffect)(() => { !ef.current && eh.viewportInitialized && n && (setTimeout(() => n(eh), 1), ef.current = !0) }, [n, eh.viewportInitialized]), ep = oB(iS), eg = oV(), (0, b.useEffect)(() => { ec && (ep?.(ec), eg.setState({ transform: [ec.x, ec.y, ec.zoom] })) }, [ec, ep]), (0, v.jsx)(rF, { onPaneClick: H, onPaneMouseEnter: F, onPaneMouseMove: X, onPaneMouseLeave: Y, onPaneContextMenu: K, onPaneScroll: Z, paneClickDistance: q, deleteKeyCode: k, selectionKeyCode: x, selectionOnDrag: w, selectionMode: S, onSelectionStart: h, onSelectionEnd: f, multiSelectionKeyCode: _, panActivationKeyCode: M, zoomActivationKeyCode: E, elementsSelectable: N, zoomOnScroll: I, zoomOnPinch: T, zoomOnDoubleClick: B, panOnScroll: R, panOnScrollSpeed: L, panOnScrollMode: O, panOnDrag: V, defaultViewport: A, translateExtent: j, minZoom: P, maxZoom: z, onSelectionContextMenu: d, preventScrolling: $, noDragClassName: er, noWheelClassName: ei, noPanClassName: ea, disableKeyboardA11y: el, onViewportChange: ed, isControlledViewport: !!ec, children: (0, v.jsxs)(iw, { children: [(0, v.jsx)(iv, { edgeTypes: t, onEdgeClick: r, onEdgeDoubleClick: a, onReconnect: et, onReconnectStart: en, onReconnectEnd: eo, onlyRenderVisibleElements: C, onEdgeContextMenu: U, onEdgeMouseEnter: G, onEdgeMouseMove: Q, onEdgeMouseLeave: J, reconnectRadius: ee, defaultMarkerColor: D, noPanClassName: ea, disableKeyboardA11y: el, rfId: eu }), (0, v.jsx)(iE, { style: g, type: p, component: m, containerStyle: y }), (0, v.jsx)("div", { className: "react-flow__edgelabel-renderer" }), (0, v.jsx)(rq, { nodeTypes: e, onNodeClick: o, onNodeDoubleClick: i, onNodeMouseEnter: l, onNodeMouseMove: s, onNodeMouseLeave: u, onNodeContextMenu: c, nodeClickDistance: W, onlyRenderVisibleElements: C, noPanClassName: ea, noDragClassName: er, disableKeyboardA11y: el, nodeExtent: es, rfId: eu }), (0, v.jsx)("div", { className: "react-flow__viewport-portal" })] }) }) } iA.displayName = "GraphView"; let ij = (0, b.memo)(iA), iP = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: a, fitViewOptions: l, minZoom: s = .5, maxZoom: u = 2, nodeOrigin: d, nodeExtent: h, zIndexMode: f = "basic" } = {}) => { let p = new Map, g = new Map, m = new Map, y = new Map, x = o ?? t ?? [], v = n ?? e ?? [], b = d ?? [0, 0], w = h ?? t8; ol(m, y, x); let S = ot(v, p, g, { nodeOrigin: b, nodeExtent: w, zIndexMode: f }), _ = [0, 0, 1]; if (a && r && i) { let { x: e, y: t, zoom: n } = nj(na(p, { filter: e => !!((e.width || e.initialWidth) && (e.height || e.initialHeight)) }), r, i, s, u, l?.padding ?? .1); _ = [e, t, n] } return { rfId: "1", width: r ?? 0, height: i ?? 0, transform: _, nodes: v, nodesInitialized: S, nodeLookup: p, parentLookup: g, edges: x, edgeLookup: y, connectionLookup: m, onNodesChange: null, onEdgesChange: null, hasDefaultNodes: void 0 !== n, hasDefaultEdges: void 0 !== o, panZoom: null, minZoom: s, maxZoom: u, translateExtent: t8, nodeExtent: w, nodesSelectionActive: !1, userSelectionActive: !1, userSelectionRect: null, connectionMode: c.Strict, domNode: null, paneDragging: !1, noPanClassName: "nopan", nodeOrigin: b, nodeDragThreshold: 1, connectionDragThreshold: 1, snapGrid: [15, 15], snapToGrid: !1, nodesDraggable: !0, nodesConnectable: !0, nodesFocusable: !0, edgesFocusable: !0, edgesReconnectable: !0, elementsSelectable: !0, elevateNodesOnSelect: !0, elevateEdgesOnSelect: !0, selectNodesOnDrag: !0, multiSelectionActive: !1, fitViewQueued: a ?? !1, fitViewOptions: l, fitViewResolver: null, connection: { ...ne }, connectionClickStartHandle: null, connectOnClick: !0, ariaLiveMessage: "", autoPanOnConnect: !0, autoPanOnNodeDrag: !0, autoPanOnNodeFocus: !0, autoPanSpeed: 15, connectionRadius: 20, onError: nE, isValidConnection: void 0, onSelectionChangeHandlers: [], lib: "react", debug: !1, ariaLabelConfig: t7, zIndexMode: f, onNodesChangeMiddlewareMap: new Map, onEdgesChangeMiddlewareMap: new Map } }; function iz({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: o, initialWidth: r, initialHeight: i, initialMinZoom: a, initialMaxZoom: l, initialFitViewOptions: s, fitView: u, nodeOrigin: c, nodeExtent: d, zIndexMode: h, children: f }) { let [p] = (0, b.useState)(() => (({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: a, fitViewOptions: l, minZoom: s, maxZoom: u, nodeOrigin: c, nodeExtent: d, zIndexMode: h }) => { let f, p; return f = (f, p) => { async function m() { let { nodeLookup: e, panZoom: t, fitViewOptions: n, fitViewResolver: o, width: r, height: i, minZoom: a, maxZoom: l } = p(); t && (await ns({ nodes: e, width: r, height: i, panZoom: t, minZoom: a, maxZoom: l }, n), o?.resolve(!0), f({ fitViewResolver: null })) } return { ...iP({ nodes: e, edges: t, width: r, height: i, fitView: a, fitViewOptions: l, minZoom: s, maxZoom: u, nodeOrigin: c, nodeExtent: d, defaultNodes: n, defaultEdges: o, zIndexMode: h }), setNodes: e => { let { nodeLookup: t, parentLookup: n, nodeOrigin: o, elevateNodesOnSelect: r, fitViewQueued: i, zIndexMode: a } = p(), l = ot(e, t, n, { nodeOrigin: o, nodeExtent: d, elevateNodesOnSelect: r, checkEquality: !0, zIndexMode: a }); i && l ? (m(), f({ nodes: e, nodesInitialized: l, fitViewQueued: !1, fitViewOptions: void 0 })) : f({ nodes: e, nodesInitialized: l }) }, setEdges: e => { let { connectionLookup: t, edgeLookup: n } = p(); ol(t, n, e), f({ edges: e }) }, setDefaultNodesAndEdges: (e, t) => { if (e) { let { setNodes: t } = p(); t(e), f({ hasDefaultNodes: !0 }) } if (t) { let { setEdges: e } = p(); e(t), f({ hasDefaultEdges: !0 }) } }, updateNodeInternals: e => { let { triggerNodeChanges: t, nodeLookup: n, parentLookup: o, domNode: r, nodeOrigin: i, nodeExtent: a, debug: l, fitViewQueued: s, zIndexMode: u } = p(), { changes: c, updatedInternals: d } = function (e, t, n, o, r, i, a) { let l = o?.querySelector(".xyflow__viewport"), s = !1; if (!l) return { changes: [], updatedInternals: s }; let u = [], c = window.getComputedStyle(l), { m22: d } = new window.DOMMatrixReadOnly(c.transform), h = []; for (let o of e.values()) { let e = t.get(o.id); if (!e) continue; if (e.hidden) { t.set(e.id, { ...e, internals: { ...e.internals, handleBounds: void 0 } }), s = !0; continue } let l = nL(o.nodeElement), c = e.measured.width !== l.width || e.measured.height !== l.height; if (l.width && l.height && (c || !e.internals.handleBounds || o.force)) { let f = o.nodeElement.getBoundingClientRect(), p = nz(e.extent) ? e.extent : i, { positionAbsolute: g } = e.internals; e.parentId && "parent" === e.extent ? g = nf(g, l, t.get(e.parentId)) : p && (g = nh(g, p, l)); let m = { ...e, measured: l, internals: { ...e.internals, positionAbsolute: g, handleBounds: { source: nF("source", o.nodeElement, f, d, e.id), target: nF("target", o.nodeElement, f, d, e.id) } } }; t.set(e.id, m), e.parentId && on(m, t, n, { nodeOrigin: r, zIndexMode: a }), s = !0, c && (u.push({ id: e.id, type: "dimensions", dimensions: l }), e.expandParent && e.parentId && h.push({ id: e.id, parentId: e.parentId, rect: nv(m, r) })) } } if (h.length > 0) { let e = or(h, t, n, r); u.push(...e) } return { changes: u, updatedInternals: s } }(e, n, o, r, i, a, u); d && (!function (e, t, n) { let o = n7(n8, n); for (let n of e.values()) if (n.parentId) on(n, e, t, o); else { let e = nh(ni(n, o.nodeOrigin), nz(n.extent) ? n.extent : o.nodeExtent, n$(n)); n.internals.positionAbsolute = e } }(n, o, { nodeOrigin: i, nodeExtent: a, zIndexMode: u }), s ? (m(), f({ fitViewQueued: !1, fitViewOptions: void 0 })) : f({}), c?.length > 0 && (l && console.log("React Flow: trigger node changes", c), t?.(c))) }, updateNodePositions: (e, t = !1) => { let n = [], o = [], { nodeLookup: r, triggerNodeChanges: i, connection: a, updateConnection: l, onNodesChangeMiddlewareMap: s } = p(); for (let [i, s] of e) { let e = r.get(i), u = !!(e?.expandParent && e?.parentId && s?.position), c = { id: i, type: "position", position: u ? { x: Math.max(0, s.position.x), y: Math.max(0, s.position.y) } : s.position, dragging: t }; if (e && a.inProgress && a.fromNode.id === e.id) { let t = n3(e, a.fromHandle, g.Left, !0); l({ ...a, from: t }) } u && e.parentId && n.push({ id: i, parentId: e.parentId, rect: { ...s.internals.positionAbsolute, width: s.measured.width ?? 0, height: s.measured.height ?? 0 } }), o.push(c) } if (n.length > 0) { let { parentLookup: e, nodeOrigin: t } = p(), i = or(n, r, e, t); o.push(...i) } for (let e of s.values()) o = e(o); i(o) }, triggerNodeChanges: e => { let { onNodesChange: t, setNodes: n, nodes: o, hasDefaultNodes: r, debug: i } = p(); e?.length && (r && n(ri(e, o)), i && console.log("React Flow: trigger node changes", e), t?.(e)) }, triggerEdgeChanges: e => { let { onEdgesChange: t, setEdges: n, edges: o, hasDefaultEdges: r, debug: i } = p(); e?.length && (r && n(ri(e, o)), i && console.log("React Flow: trigger edge changes", e), t?.(e)) }, addSelectedNodes: e => { let { multiSelectionActive: t, edgeLookup: n, nodeLookup: o, triggerNodeChanges: r, triggerEdgeChanges: i } = p(); t ? r(e.map(e => ra(e, !0))) : (r(rl(o, new Set([...e]), !0)), i(rl(n))) }, addSelectedEdges: e => { let { multiSelectionActive: t, edgeLookup: n, nodeLookup: o, triggerNodeChanges: r, triggerEdgeChanges: i } = p(); t ? i(e.map(e => ra(e, !0))) : (i(rl(n, new Set([...e]))), r(rl(o, new Set, !0))) }, unselectNodesAndEdges: ({ nodes: e, edges: t } = {}) => { let { edges: n, nodes: o, nodeLookup: r, triggerNodeChanges: i, triggerEdgeChanges: a } = p(), l = (e || o).map(e => { let t = r.get(e.id); return t && (t.selected = !1), ra(e.id, !1) }), s = (t || n).map(e => ra(e.id, !1)); i(l), a(s) }, setMinZoom: e => { let { panZoom: t, maxZoom: n } = p(); t?.setScaleExtent([e, n]), f({ minZoom: e }) }, setMaxZoom: e => { let { panZoom: t, minZoom: n } = p(); t?.setScaleExtent([n, e]), f({ maxZoom: e }) }, setTranslateExtent: e => { p().panZoom?.setTranslateExtent(e), f({ translateExtent: e }) }, resetSelectedElements: () => { let { edges: e, nodes: t, triggerNodeChanges: n, triggerEdgeChanges: o, elementsSelectable: r } = p(); if (!r) return; let i = t.reduce((e, t) => t.selected ? [...e, ra(t.id, !1)] : e, []), a = e.reduce((e, t) => t.selected ? [...e, ra(t.id, !1)] : e, []); n(i), o(a) }, setNodeExtent: e => { let { nodes: t, nodeLookup: n, parentLookup: o, nodeOrigin: r, elevateNodesOnSelect: i, nodeExtent: a, zIndexMode: l } = p(); (e[0][0] !== a[0][0] || e[0][1] !== a[0][1] || e[1][0] !== a[1][0] || e[1][1] !== a[1][1]) && (ot(t, n, o, { nodeOrigin: r, nodeExtent: e, elevateNodesOnSelect: i, checkEquality: !1, zIndexMode: l }), f({ nodeExtent: e })) }, panBy: e => { let { transform: t, width: n, height: o, panZoom: r, translateExtent: i } = p(); return oi({ delta: e, panZoom: r, transform: t, translateExtent: i, width: n, height: o }) }, setCenter: async (e, t, n) => { let { width: o, height: r, maxZoom: i, panZoom: a } = p(); if (!a) return Promise.resolve(!1); let l = void 0 !== n?.zoom ? n.zoom : i; return await a.setViewport({ x: o / 2 - e * l, y: r / 2 - t * l, zoom: l }, { duration: n?.duration, ease: n?.ease, interpolate: n?.interpolate }), Promise.resolve(!0) }, cancelConnection: () => { f({ connection: { ...ne } }) }, updateConnection: e => { f({ connection: e }) }, reset: () => f({ ...iP() }) } }, p = Object.is, f ? oI(f, p) : oI })({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: u, minZoom: a, maxZoom: l, fitViewOptions: s, nodeOrigin: c, nodeExtent: d, zIndexMode: h })); return (0, v.jsx)(oL, { value: p, children: (0, v.jsx)(rg, { children: f }) }) } function i$({ children: e, nodes: t, edges: n, defaultNodes: o, defaultEdges: r, width: i, height: a, fitView: l, fitViewOptions: s, minZoom: u, maxZoom: c, nodeOrigin: d, nodeExtent: h, zIndexMode: f }) { return (0, b.useContext)(oR) ? (0, v.jsx)(v.Fragment, { children: e }) : (0, v.jsx)(iz, { initialNodes: t, initialEdges: n, defaultNodes: o, defaultEdges: r, initialWidth: i, initialHeight: a, fitView: l, initialFitViewOptions: s, initialMinZoom: u, initialMaxZoom: c, nodeOrigin: d, nodeExtent: h, zIndexMode: f, children: e }) } let iD = { width: "100%", height: "100%", overflow: "hidden", position: "relative", zIndex: 0 }; var iI = rd(function ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, className: r, nodeTypes: i, edgeTypes: a, onNodeClick: l, onEdgeClick: s, onInit: u, onMove: c, onMoveStart: p, onMoveEnd: g, onConnect: m, onConnectStart: y, onConnectEnd: x, onClickConnectStart: S, onClickConnectEnd: _, onNodeMouseEnter: M, onNodeMouseMove: E, onNodeMouseLeave: k, onNodeContextMenu: C, onNodeDoubleClick: N, onNodeDragStart: A, onNodeDrag: j, onNodeDragStop: P, onNodesDelete: z, onEdgesDelete: $, onDelete: D, onSelectionChange: I, onSelectionDragStart: T, onSelectionDrag: R, onSelectionDragStop: L, onSelectionContextMenu: O, onSelectionStart: B, onSelectionEnd: V, onBeforeDelete: H, connectionMode: F, connectionLineType: X = f.Bezier, connectionLineStyle: Y, connectionLineComponent: Z, connectionLineContainerStyle: K, deleteKeyCode: q = "Backspace", selectionKeyCode: W = "Shift", selectionOnDrag: U = !1, selectionMode: G = h.Full, panActivationKeyCode: Q = "Space", multiSelectionKeyCode: J = nP() ? "Meta" : "Control", zoomActivationKeyCode: ee = nP() ? "Meta" : "Control", snapToGrid: et, snapGrid: en, onlyRenderVisibleElements: eo = !1, selectNodesOnDrag: er, nodesDraggable: ei, autoPanOnNodeFocus: ea, nodesConnectable: el, nodesFocusable: es, nodeOrigin: eu = o3, edgesFocusable: ec, edgesReconnectable: ed, elementsSelectable: eh = !0, defaultViewport: ef = o4, minZoom: ep = .5, maxZoom: eg = 2, translateExtent: em = t8, preventScrolling: ey = !0, nodeExtent: ex, defaultMarkerColor: ev = "#b1b1b7", zoomOnScroll: eb = !0, zoomOnPinch: ew = !0, panOnScroll: eS = !1, panOnScrollSpeed: e_ = .5, panOnScrollMode: eM = d.Free, zoomOnDoubleClick: eE = !0, panOnDrag: ek = !0, onPaneClick: eC, onPaneMouseEnter: eN, onPaneMouseMove: eA, onPaneMouseLeave: ej, onPaneScroll: eP, onPaneContextMenu: ez, paneClickDistance: e$ = 1, nodeClickDistance: eD = 0, children: eI, onReconnect: eT, onReconnectStart: eR, onReconnectEnd: eL, onEdgeContextMenu: eO, onEdgeDoubleClick: eB, onEdgeMouseEnter: eV, onEdgeMouseMove: eH, onEdgeMouseLeave: eF, reconnectRadius: eX = 10, onNodesChange: eY, onEdgesChange: eZ, noDragClassName: eK = "nodrag", noWheelClassName: eq = "nowheel", noPanClassName: eW = "nopan", fitView: eU, fitViewOptions: eG, connectOnClick: eQ, attributionPosition: eJ, proOptions: e0, defaultEdgeOptions: e1, elevateNodesOnSelect: e2 = !0, elevateEdgesOnSelect: e5 = !1, disableKeyboardA11y: e3 = !1, autoPanOnConnect: e4, autoPanOnNodeDrag: e6, autoPanSpeed: e8, connectionRadius: e9, isValidConnection: e7, onError: te, style: tt, id: tn, nodeDragThreshold: to, connectionDragThreshold: tr, viewport: ti, onViewportChange: ta, width: tl, height: ts, colorMode: tu = "light", debug: tc, onScroll: td, ariaLabelConfig: th, zIndexMode: tf = "basic", ...tp }, tg) { let tm = tn || "1", ty = function (e) { let [t, n] = (0, b.useState)("system" === e ? null : e); return (0, b.useEffect)(() => { if ("system" !== e) return void n(e); let t = re(), o = () => n(t?.matches ? "dark" : "light"); return o(), t?.addEventListener("change", o), () => { t?.removeEventListener("change", o) } }, [e]), null !== t ? t : re()?.matches ? "dark" : "light" }(tu), tx = (0, b.useCallback)(e => { e.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), td?.(e) }, [td]); return (0, v.jsx)("div", { "data-testid": "rf__wrapper", ...tp, onScroll: tx, style: { ...tt, ...iD }, ref: tg, className: w(["react-flow", r, ty]), id: tn, role: "application", children: (0, v.jsxs)(i$, { nodes: e, edges: t, width: tl, height: ts, fitView: eU, fitViewOptions: eG, minZoom: ep, maxZoom: eg, nodeOrigin: eu, nodeExtent: ex, zIndexMode: tf, children: [(0, v.jsx)(ij, { onInit: u, onNodeClick: l, onEdgeClick: s, onNodeMouseEnter: M, onNodeMouseMove: E, onNodeMouseLeave: k, onNodeContextMenu: C, onNodeDoubleClick: N, nodeTypes: i, edgeTypes: a, connectionLineType: X, connectionLineStyle: Y, connectionLineComponent: Z, connectionLineContainerStyle: K, selectionKeyCode: W, selectionOnDrag: U, selectionMode: G, deleteKeyCode: q, multiSelectionKeyCode: J, panActivationKeyCode: Q, zoomActivationKeyCode: ee, onlyRenderVisibleElements: eo, defaultViewport: ef, translateExtent: em, minZoom: ep, maxZoom: eg, preventScrolling: ey, zoomOnScroll: eb, zoomOnPinch: ew, zoomOnDoubleClick: eE, panOnScroll: eS, panOnScrollSpeed: e_, panOnScrollMode: eM, panOnDrag: ek, onPaneClick: eC, onPaneMouseEnter: eN, onPaneMouseMove: eA, onPaneMouseLeave: ej, onPaneScroll: eP, onPaneContextMenu: ez, paneClickDistance: e$, nodeClickDistance: eD, onSelectionContextMenu: O, onSelectionStart: B, onSelectionEnd: V, onReconnect: eT, onReconnectStart: eR, onReconnectEnd: eL, onEdgeContextMenu: eO, onEdgeDoubleClick: eB, onEdgeMouseEnter: eV, onEdgeMouseMove: eH, onEdgeMouseLeave: eF, reconnectRadius: eX, defaultMarkerColor: ev, noDragClassName: eK, noWheelClassName: eq, noPanClassName: eW, rfId: tm, disableKeyboardA11y: e3, nodeExtent: ex, viewport: ti, onViewportChange: ta }), (0, v.jsx)(o7, { nodes: e, edges: t, defaultNodes: n, defaultEdges: o, onConnect: m, onConnectStart: y, onConnectEnd: x, onClickConnectStart: S, onClickConnectEnd: _, nodesDraggable: ei, autoPanOnNodeFocus: ea, nodesConnectable: el, nodesFocusable: es, edgesFocusable: ec, edgesReconnectable: ed, elementsSelectable: eh, elevateNodesOnSelect: e2, elevateEdgesOnSelect: e5, minZoom: ep, maxZoom: eg, nodeExtent: ex, onNodesChange: eY, onEdgesChange: eZ, snapToGrid: et, snapGrid: en, connectionMode: F, translateExtent: em, connectOnClick: eQ, defaultEdgeOptions: e1, fitView: eU, fitViewOptions: eG, onNodesDelete: z, onEdgesDelete: $, onDelete: D, onNodeDragStart: A, onNodeDrag: j, onNodeDragStop: P, onSelectionDrag: R, onSelectionDragStart: T, onSelectionDragStop: L, onMove: c, onMoveStart: p, onMoveEnd: g, noPanClassName: eW, nodeOrigin: eu, rfId: tm, autoPanOnConnect: e4, autoPanOnNodeDrag: e6, autoPanSpeed: e8, onError: te, connectionRadius: e9, isValidConnection: e7, selectNodesOnDrag: er, nodeDragThreshold: to, connectionDragThreshold: tr, onBeforeDelete: H, debug: tc, ariaLabelConfig: th, zIndexMode: tf }), (0, v.jsx)(o5, { onSelectionChange: I }), eI, (0, v.jsx)(oG, { proOptions: e0, position: eJ }), (0, v.jsx)(oW, { rfId: tm, disableKeyboardA11y: e3 })] }) }) }); function iT({ dimensions: e, lineWidth: t, variant: n, className: o }) { return (0, v.jsx)("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: w(["react-flow__background-pattern", n, o]) }) } function iR({ radius: e, className: t }) { return (0, v.jsx)("circle", { cx: e, cy: e, r: e, className: w(["react-flow__background-pattern", "dots", t]) }) } (s = y || (y = {})).Lines = "lines", s.Dots = "dots", s.Cross = "cross"; let iL = { [y.Dots]: 1, [y.Lines]: 1, [y.Cross]: 6 }, iO = e => ({ transform: e.transform, patternId: `pattern-${e.rfId}` }); function iB({ id: e, variant: t = y.Dots, gap: n = 20, size: o, lineWidth: r = 1, offset: i = 0, color: a, bgColor: l, style: s, className: u, patternClassName: c }) { let d = (0, b.useRef)(null), { transform: h, patternId: f } = oB(iO, oT), p = o || iL[t], g = t === y.Dots, m = t === y.Cross, x = Array.isArray(n) ? n : [n, n], S = [x[0] * h[2] || 1, x[1] * h[2] || 1], _ = p * h[2], M = Array.isArray(i) ? i : [i, i], E = m ? [_, _] : S, k = [M[0] * h[2] || 1 + E[0] / 2, M[1] * h[2] || 1 + E[1] / 2], C = `${f}${e || ""}`; return (0, v.jsxs)("svg", { className: w(["react-flow__background", u]), style: { ...s, ...rb, "--xy-background-color-props": l, "--xy-background-pattern-color-props": a }, ref: d, "data-testid": "rf__background", children: [(0, v.jsx)("pattern", { id: C, x: h[0] % S[0], y: h[1] % S[1], width: S[0], height: S[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${k[0]},-${k[1]})`, children: g ? (0, v.jsx)(iR, { radius: _ / 2, className: c }) : (0, v.jsx)(iT, { dimensions: E, lineWidth: r, variant: t, className: c }) }), (0, v.jsx)("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${C})` })] }) } iB.displayName = "Background"; let iV = (0, b.memo)(iB); function iH() { return (0, v.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: (0, v.jsx)("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) }) } function iF() { return (0, v.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: (0, v.jsx)("path", { d: "M0 0h32v4.2H0z" }) }) } function iX() { return (0, v.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: (0, v.jsx)("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) }) } function iY() { return (0, v.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: (0, v.jsx)("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) }) } function iZ() { return (0, v.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: (0, v.jsx)("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) }) } function iK({ children: e, className: t, ...n }) { return (0, v.jsx)("button", { type: "button", className: w(["react-flow__controls-button", t]), ...n, children: e }) } let iq = e => ({ isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable, minZoomReached: e.transform[2] <= e.minZoom, maxZoomReached: e.transform[2] >= e.maxZoom, ariaLabelConfig: e.ariaLabelConfig }); function iW({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: o = !0, fitViewOptions: r, onZoomIn: i, onZoomOut: a, onFitView: l, onInteractiveChange: s, className: u, children: c, position: d = "bottom-left", orientation: h = "vertical", "aria-label": f }) { let p = oV(), { isInteractive: g, minZoomReached: m, maxZoomReached: y, ariaLabelConfig: x } = oB(iq, oT), { zoomIn: b, zoomOut: S, fitView: _ } = ry(); return (0, v.jsxs)(oU, { className: w(["react-flow__controls", "horizontal" === h ? "horizontal" : "vertical", u]), position: d, style: e, "data-testid": "rf__controls", "aria-label": f ?? x["controls.ariaLabel"], children: [t && (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(iK, { onClick: () => { b(), i?.() }, className: "react-flow__controls-zoomin", title: x["controls.zoomIn.ariaLabel"], "aria-label": x["controls.zoomIn.ariaLabel"], disabled: y, children: (0, v.jsx)(iH, {}) }), (0, v.jsx)(iK, { onClick: () => { S(), a?.() }, className: "react-flow__controls-zoomout", title: x["controls.zoomOut.ariaLabel"], "aria-label": x["controls.zoomOut.ariaLabel"], disabled: m, children: (0, v.jsx)(iF, {}) })] }), n && (0, v.jsx)(iK, { className: "react-flow__controls-fitview", onClick: () => { _(r), l?.() }, title: x["controls.fitView.ariaLabel"], "aria-label": x["controls.fitView.ariaLabel"], children: (0, v.jsx)(iX, {}) }), o && (0, v.jsx)(iK, { className: "react-flow__controls-interactive", onClick: () => { p.setState({ nodesDraggable: !g, nodesConnectable: !g, elementsSelectable: !g }), s?.(!g) }, title: x["controls.interactive.ariaLabel"], "aria-label": x["controls.interactive.ariaLabel"], children: g ? (0, v.jsx)(iZ, {}) : (0, v.jsx)(iY, {}) }), c] }) } iW.displayName = "Controls"; let iU = (0, b.memo)(iW), iG = (0, b.memo)(function ({ id: e, x: t, y: n, width: o, height: r, style: i, color: a, strokeColor: l, strokeWidth: s, className: u, borderRadius: c, shapeRendering: d, selected: h, onClick: f }) { let { background: p, backgroundColor: g } = i || {}; return (0, v.jsx)("rect", { className: w(["react-flow__minimap-node", { selected: h }, u]), x: t, y: n, rx: c, ry: c, width: o, height: r, style: { fill: a || p || g, stroke: l, strokeWidth: s }, shapeRendering: d, onClick: f ? t => f(t, e) : void 0 }) }), iQ = e => e.nodes.map(e => e.id), iJ = e => e instanceof Function ? e : () => e, i0 = (0, b.memo)(function ({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: o, nodeBorderRadius: r, nodeStrokeWidth: i, shapeRendering: a, NodeComponent: l, onClick: s }) { let { node: u, x: c, y: d, width: h, height: f } = oB(t => { let { internals: n } = t.nodeLookup.get(e), o = n.userNode, { x: r, y: i } = n.positionAbsolute, { width: a, height: l } = n$(o); return { node: o, x: r, y: i, width: a, height: l } }, oT); return u && !u.hidden && nD(u) ? (0, v.jsx)(l, { x: c, y: d, width: h, height: f, style: u.style, selected: !!u.selected, className: o(u), color: t(u), borderRadius: r, strokeColor: n(u), strokeWidth: i, shapeRendering: a, onClick: s, id: u.id }) : null }); var i1 = (0, b.memo)(function ({ nodeStrokeColor: e, nodeColor: t, nodeClassName: n = "", nodeBorderRadius: o = 5, nodeStrokeWidth: r, nodeComponent: i = iG, onClick: a }) { let l = oB(iQ, oT), s = iJ(t), u = iJ(e), c = iJ(n), d = "u" < typeof window || window.chrome ? "crispEdges" : "geometricPrecision"; return (0, v.jsx)(v.Fragment, { children: l.map(e => (0, v.jsx)(i0, { id: e, nodeColorFunc: s, nodeStrokeColorFunc: u, nodeClassNameFunc: c, nodeBorderRadius: o, nodeStrokeWidth: r, NodeComponent: i, onClick: a, shapeRendering: d }, e)) }) }); let i2 = e => !e.hidden, i5 = e => { let t = { x: -e.transform[0] / e.transform[2], y: -e.transform[1] / e.transform[2], width: e.width / e.transform[2], height: e.height / e.transform[2] }; return { viewBB: t, boundingRect: e.nodeLookup.size > 0 ? nw(na(e.nodeLookup, { filter: i2 }), t) : t, rfId: e.rfId, panZoom: e.panZoom, translateExtent: e.translateExtent, flowWidth: e.width, flowHeight: e.height, ariaLabelConfig: e.ariaLabelConfig } }; function i3({ style: e, className: t, nodeStrokeColor: n, nodeColor: o, nodeClassName: r = "", nodeBorderRadius: i = 5, nodeStrokeWidth: a, nodeComponent: l, bgColor: s, maskColor: u, maskStrokeColor: c, maskStrokeWidth: d, position: h = "bottom-right", onClick: f, onNodeClick: p, pannable: g = !1, zoomable: m = !1, ariaLabel: y, inversePan: x, zoomStep: S = 1, offsetScale: _ = 5 }) {
                let M = oV(), E = (0, b.useRef)(null), { boundingRect: k, viewBB: C, rfId: N, panZoom: A, translateExtent: j, flowWidth: P, flowHeight: z, ariaLabelConfig: $ } = oB(i5, oT), D = e?.width ?? 200, I = e?.height ?? 150, T = Math.max(k.width / D, k.height / I), R = T * D, L = T * I, O = _ * T, B = k.x - (R - k.width) / 2 - O, V = k.y - (L - k.height) / 2 - O, H = R + 2 * O, F = L + 2 * O, X = `react-flow__minimap-desc-${N}`, Y = (0, b.useRef)(0), Z = (0, b.useRef)(); Y.current = T, (0, b.useEffect)(() => { if (E.current && A) return Z.current = function ({ domNode: e, panZoom: t, getTransform: n, getViewScale: o }) { let r = ef(e); return { update: function ({ translateExtent: e, width: i, height: a, zoomStep: l = 1, pannable: s = !0, zoomable: u = !0, inversePan: c = !1 }) { let d = [0, 0], h = t4().on("start", e => { ("mousedown" === e.sourceEvent.type || "touchstart" === e.sourceEvent.type) && (d = [e.sourceEvent.clientX ?? e.sourceEvent.touches[0].clientX, e.sourceEvent.clientY ?? e.sourceEvent.touches[0].clientY]) }).on("zoom", s ? r => { let l = n(); if ("mousemove" !== r.sourceEvent.type && "touchmove" !== r.sourceEvent.type || !t) return; let s = [r.sourceEvent.clientX ?? r.sourceEvent.touches[0].clientX, r.sourceEvent.clientY ?? r.sourceEvent.touches[0].clientY], u = [s[0] - d[0], s[1] - d[1]]; d = s; let h = o() * Math.max(l[2], Math.log(l[2])) * (c ? -1 : 1), f = { x: l[0] - u[0] * h, y: l[1] - u[1] * h }; t.setViewportConstrained({ x: f.x, y: f.y, zoom: l[2] }, [[0, 0], [i, a]], e) } : null).on("zoom.wheel", u ? e => { if ("wheel" !== e.sourceEvent.type || !t) return; let o = n(), r = e.sourceEvent.ctrlKey && nP() ? 10 : 1, i = -e.sourceEvent.deltaY * (1 === e.sourceEvent.deltaMode ? .05 : e.sourceEvent.deltaMode ? 1 : .002) * l, a = o[2] * Math.pow(2, i * r); t.scaleTo(a) } : null); r.call(h, {}) }, destroy: function () { r.on("zoom", null) }, pointer: ep } }({ domNode: E.current, panZoom: A, getTransform: () => M.getState().transform, getViewScale: () => Y.current }), () => { Z.current?.destroy() } }, [A]), (0, b.useEffect)(() => { Z.current?.update({ translateExtent: j, width: P, height: z, inversePan: x, pannable: g, zoomStep: S, zoomable: m }) }, [g, m, x, S, j, P, z]); let K = f ? e => { let [t, n] = Z.current?.pointer(e) || [0, 0]; f(e, { x: t, y: n }) } : void 0, q = p ? (0, b.useCallback)((e, t) => { p(e, M.getState().nodeLookup.get(t).internals.userNode) }, []) : void 0, W = y ?? $["minimap.ariaLabel"]; return (0, v.jsx)(oU, {
                        position: h, style: { ...e, "--xy-minimap-background-color-props": "string" == typeof s ? s : void 0, "--xy-minimap-mask-background-color-props": "string" == typeof u ? u : void 0, "--xy-minimap-mask-stroke-color-props": "string" == typeof c ? c : void 0, "--xy-minimap-mask-stroke-width-props": "number" == typeof d ? d * T : void 0, "--xy-minimap-node-background-color-props": "string" == typeof o ? o : void 0, "--xy-minimap-node-stroke-color-props": "string" == typeof n ? n : void 0, "--xy-minimap-node-stroke-width-props": "number" == typeof a ? a : void 0 }, className: w(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: (0, v.jsxs)("svg", {
                                width: D, height: I, viewBox: `${B} ${V} ${H} ${F}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": X, ref: E, onClick: K, children: [W && (0, v.jsx)("title", { id: X, children: W }), (0, v.jsx)(i1, { onClick: q, nodeColor: o, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: r, nodeStrokeWidth: a, nodeComponent: l }), (0, v.jsx)("path", {
                                        className: "react-flow__minimap-mask", d: `M${B - O},${V - O}h${H + 2 * O}v${F + 2 * O}h${-H - 2 * O}z
        M${C.x},${C.y}h${C.width}v${C.height}h${-C.width}z`, fillRule: "evenodd", pointerEvents: "none"
                                })]
                        })
                })
        } i3.displayName = "MiniMap"; let i4 = (0, b.memo)(i3), i6 = { [m.Line]: "right", [m.Handle]: "bottom-right" }; (0, b.memo)(function ({ nodeId: e, position: t, variant: n = m.Handle, className: o, style: r, children: i, color: a, minWidth: l = 10, minHeight: s = 10, maxWidth: u = Number.MAX_VALUE, maxHeight: c = Number.MAX_VALUE, keepAspectRatio: d = !1, resizeDirection: h, autoScale: f = !0, shouldResize: p, onResizeStart: g, onResize: y, onResizeEnd: x }) { let S, _ = r$(), M = "string" == typeof e ? e : _, E = oV(), k = (0, b.useRef)(null), C = n === m.Handle, N = oB((0, b.useCallback)((S = C && f, e => S ? `${Math.max(1 / e.transform[2], 1)}` : void 0), [C, f]), oT), A = (0, b.useRef)(null), j = t ?? i6[n]; (0, b.useEffect)(() => { if (k.current && M) return A.current || (A.current = function ({ domNode: e, nodeId: t, getStoreItems: n, onChange: o, onEnd: r }) { let i = ef(e), a = { controlDirection: oS("bottom-right"), boundaries: { minWidth: 0, minHeight: 0, maxWidth: Number.MAX_VALUE, maxHeight: Number.MAX_VALUE }, resizeDirection: void 0, keepAspectRatio: !1 }; return { update: function ({ controlPosition: e, boundaries: l, keepAspectRatio: s, resizeDirection: u, onResizeStart: c, onResize: d, onResizeEnd: h, shouldResize: f }) { let p, g, m, y, x = { ...ok }, v = { ...oC }; a = { boundaries: l, resizeDirection: u, keepAspectRatio: s, controlDirection: oS(e) }; let b = null, w = [], S = !1, _ = eC().on("start", e => { let { nodeLookup: o, transform: r, snapGrid: i, snapToGrid: a, nodeOrigin: l, paneDomNode: s } = n(); if (!(p = o.get(t))) return; b = s?.getBoundingClientRect() ?? null; let { xSnapped: u, ySnapped: d } = nR(e.sourceEvent, { transform: r, snapGrid: i, snapToGrid: a, containerBounds: b }); if (v = { ...x = { width: p.measured.width ?? 0, height: p.measured.height ?? 0, x: p.position.x ?? 0, y: p.position.y ?? 0 }, pointerX: u, pointerY: d, aspectRatio: x.width / x.height }, g = void 0, p.parentId && ("parent" === p.extent || p.expandParent)) { var h; m = (g = o.get(p.parentId)) && "parent" === p.extent ? [[0, 0], [(h = g).measured.width, h.measured.height]] : void 0 } for (let [e, n] of (w = [], y = void 0, o)) if (n.parentId === t && (w.push({ id: e, position: { ...n.position }, extent: n.extent }), "parent" === n.extent || n.expandParent)) { let e = function (e, t, n) { let o = t.position.x + e.position.x, r = t.position.y + e.position.y, i = e.measured.width ?? 0, a = e.measured.height ?? 0, l = n[0] * i, s = n[1] * a; return [[o - l, r - s], [o + i - l, r + a - s]] }(n, p, n.origin ?? l); y = y ? [[Math.min(e[0][0], y[0][0]), Math.min(e[0][1], y[0][1])], [Math.max(e[1][0], y[1][0]), Math.max(e[1][1], y[1][1])]] : e } c?.(e, { ...x }) }).on("drag", e => { let { transform: t, snapGrid: r, snapToGrid: i, nodeOrigin: l } = n(), s = nR(e.sourceEvent, { transform: t, snapGrid: r, snapToGrid: i, containerBounds: b }), u = []; if (!p) return; let { x: c, y: h, width: _, height: M } = x, E = {}, k = p.origin ?? l, { width: C, height: N, x: A, y: j } = function (e, t, n, o, r, i, a, l) { var s, u, c, d; let { affectsX: h, affectsY: f } = t, { isHorizontal: p, isVertical: g } = t, m = p && g, { xSnapped: y, ySnapped: x } = n, { minWidth: v, maxWidth: b, minHeight: w, maxHeight: S } = o, { x: _, y: M, width: E, height: k, aspectRatio: C } = e, N = Math.floor(p ? y - e.pointerX : 0), A = Math.floor(g ? x - e.pointerY : 0), j = E + (h ? -N : N), P = k + (f ? -A : A), z = -i[0] * E, $ = -i[1] * k, D = oE(j, v, b), I = oE(P, w, S); if (a) { let e = 0, t = 0; h && N < 0 ? e = o_(_ + N + z, a[0][0]) : !h && N > 0 && (e = oM(_ + j + z, a[1][0])), f && A < 0 ? t = o_(M + A + $, a[0][1]) : !f && A > 0 && (t = oM(M + P + $, a[1][1])), D = Math.max(D, e), I = Math.max(I, t) } if (l) { let e = 0, t = 0; h && N > 0 ? e = oM(_ + N, l[0][0]) : !h && N < 0 && (e = o_(_ + j, l[1][0])), f && A > 0 ? t = oM(M + A, l[0][1]) : !f && A < 0 && (t = o_(M + P, l[1][1])), D = Math.max(D, e), I = Math.max(I, t) } if (r) { if (p) { (D = Math.max(D, oE(j / C, w, S) * C), a) && (D = Math.max(D, (h || f) && (!h || f || !m) ? o_(M + $ + (h ? N : -N) / C, a[0][1]) * C : oM(M + $ + j / C, a[1][1]) * C)); l && (D = Math.max(D, (h || f) && (!h || f || !m) ? oM(M + (h ? N : -N) / C, l[0][1]) * C : o_(M + j / C, l[1][1]) * C)) } if (g) { (I = Math.max(I, oE(P * C, v, b) / C), a) && (I = Math.max(I, (h || f) && (!f || h || !m) ? o_(_ + (f ? A : -A) * C + z, a[0][0]) / C : oM(_ + P * C + z, a[1][0]) / C)); l && (I = Math.max(I, (h || f) && (!f || h || !m) ? oM(_ + (f ? A : -A) * C, l[0][0]) / C : o_(_ + P * C, l[1][0]) / C)) } } A += A < 0 ? I : -I, N += N < 0 ? D : -D, r && (m ? j > P * C ? A = ((s = h, u = f, s ? !u : u) ? -N : N) / C : N = ((c = h, d = f, c ? !d : d) ? -A : A) * C : p ? (A = N / C, f = h) : (N = A * C, h = f)); let T = h ? _ + N : _, R = f ? M + A : M; return { width: E + (h ? -N : N), height: k + (f ? -A : A), x: i[0] * N * (h ? -1 : 1) + T, y: i[1] * A * (f ? -1 : 1) + R } }(v, a.controlDirection, s, a.boundaries, a.keepAspectRatio, k, m, y), P = C !== _, z = N !== M, $ = A !== c && P, D = j !== h && z; if (!$ && !D && !P && !z) return; if (($ || D || 1 === k[0] || 1 === k[1]) && (E.x = $ ? A : x.x, E.y = D ? j : x.y, x.x = E.x, x.y = E.y, w.length > 0)) { let e = A - c, t = j - h; for (let n of w) n.position = { x: n.position.x - e + k[0] * (C - _), y: n.position.y - t + k[1] * (N - M) }, u.push(n) } if ((P || z) && (E.width = P && (!a.resizeDirection || "horizontal" === a.resizeDirection) ? C : x.width, E.height = z && (!a.resizeDirection || "vertical" === a.resizeDirection) ? N : x.height, x.width = E.width, x.height = E.height), g && p.expandParent) { let e = k[0] * (E.width ?? 0); E.x && E.x < e && (x.x = e, v.x = v.x - (E.x - e)); let t = k[1] * (E.height ?? 0); E.y && E.y < t && (x.y = t, v.y = v.y - (E.y - t)) } let I = function ({ width: e, prevWidth: t, height: n, prevHeight: o, affectsX: r, affectsY: i }) { let a = e - t, l = n - o, s = [a > 0 ? 1 : a < 0 ? -1 : 0, l > 0 ? 1 : l < 0 ? -1 : 0]; return a && r && (s[0] = -1 * s[0]), l && i && (s[1] = -1 * s[1]), s }({ width: x.width, prevWidth: _, height: x.height, prevHeight: M, affectsX: a.controlDirection.affectsX, affectsY: a.controlDirection.affectsY }), T = { ...x, direction: I }; !1 !== f?.(e, T) && (S = !0, d?.(e, T), o(E, u)) }).on("end", e => { S && (h?.(e, { ...x }), r?.({ ...x }), S = !1) }); i.call(_) }, destroy: function () { i.on(".drag", null) } } }({ domNode: k.current, nodeId: M, getStoreItems: () => { let { nodeLookup: e, transform: t, snapGrid: n, snapToGrid: o, nodeOrigin: r, domNode: i } = E.getState(); return { nodeLookup: e, transform: t, snapGrid: n, snapToGrid: o, nodeOrigin: r, paneDomNode: i } }, onChange: (e, t) => { let { triggerNodeChanges: n, nodeLookup: o, parentLookup: r, nodeOrigin: i } = E.getState(), a = [], l = { x: e.x, y: e.y }, s = o.get(M); if (s && s.expandParent && s.parentId) { let t = s.origin ?? i, n = e.width ?? s.measured.width ?? 0, u = e.height ?? s.measured.height ?? 0, c = or([{ id: s.id, parentId: s.parentId, rect: { width: n, height: u, ...nI({ x: e.x ?? s.position.x, y: e.y ?? s.position.y }, { width: n, height: u }, s.parentId, o, t) } }], o, r, i); a.push(...c), l.x = e.x ? Math.max(t[0] * n, e.x) : void 0, l.y = e.y ? Math.max(t[1] * u, e.y) : void 0 } if (void 0 !== l.x && void 0 !== l.y) { let e = { id: M, type: "position", position: { ...l } }; a.push(e) } if (void 0 !== e.width && void 0 !== e.height) { let t = { id: M, type: "dimensions", resizing: !0, setAttributes: !h || ("horizontal" === h ? "width" : "height"), dimensions: { width: e.width, height: e.height } }; a.push(t) } for (let e of t) { let t = { ...e, type: "position" }; a.push(t) } n(a) }, onEnd: ({ width: e, height: t }) => { E.getState().triggerNodeChanges([{ id: M, type: "dimensions", resizing: !1, dimensions: { width: e, height: t } }]) } })), A.current.update({ controlPosition: j, boundaries: { minWidth: l, minHeight: s, maxWidth: u, maxHeight: c }, keepAspectRatio: d, resizeDirection: h, onResizeStart: g, onResize: y, onResizeEnd: x, shouldResize: p }), () => { A.current?.destroy() } }, [j, l, s, u, c, d, g, y, x, p]); let P = j.split("-"); return (0, v.jsx)("div", { className: w(["react-flow__resize-control", "nodrag", ...P, n, o]), ref: k, style: { ...r, scale: N, ...a && { [C ? "backgroundColor" : "borderColor"]: a } }, children: i }) }); var i8 = e.i(19930), i9 = e.i(70173), i7 = e.i(35633); let ae = (0, i7.default)("save", [["path", { d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z", key: "1c8476" }], ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }], ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]]), at = (0, i7.default)("play", [["path", { d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z", key: "10ikf1" }]]); var an = e.i(40023), ao = e.i(1335), ar = e.i(85612); let ai = (0, i7.default)("database", [["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }], ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }], ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]]); var aa = e.i(62325), al = e.i(43361), as = e.i(92844); let au = (0, i7.default)("mouse-pointer-2", [["path", { d: "M4.037 4.688a.495.495 0 0 1 .651-.651l16 6.5a.5.5 0 0 1-.063.947l-6.124 1.58a2 2 0 0 0-1.438 1.435l-1.579 6.126a.5.5 0 0 1-.947.063z", key: "edeuup" }]]); var ac = e.i(13737), ad = e.i(31835); let ah = (0, i7.default)("container", [["path", { d: "M22 7.7c0-.6-.4-1.2-.8-1.5l-6.3-3.9a1.72 1.72 0 0 0-1.7 0l-10.3 6c-.5.2-.9.8-.9 1.4v6.6c0 .5.4 1.2.8 1.5l6.3 3.9a1.72 1.72 0 0 0 1.7 0l10.3-6c.5-.3.9-1 .9-1.5Z", key: "1t2lqe" }], ["path", { d: "M10 21.9V14L2.1 9.1", key: "o7czzq" }], ["path", { d: "m10 14 11.9-6.9", key: "zm5e20" }], ["path", { d: "M14 19.8v-8.1", key: "159ecu" }], ["path", { d: "M18 17.5V9.4", key: "11uown" }]]), af = (0, i7.default)("hard-drive", [["line", { x1: "22", x2: "2", y1: "12", y2: "12", key: "1y58io" }], ["path", { d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z", key: "oot6mr" }], ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16", key: "sgf278" }], ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16", key: "1l4acy" }]]), ap = (0, i7.default)("lock", [["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }], ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]]), ag = (0, i7.default)("activity", [["path", { d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2", key: "169zse" }]]); var am = e.i(92912); let ay = (0, i7.default)("box", [["path", { d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z", key: "hh9hay" }], ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }], ["path", { d: "M12 22V12", key: "d0xqtd" }]]); var ax = e.i(79276), av = e.i(92662), ab = e.i(29458), aw = e.i(40913), aS = e.i(56818), a_ = e.i(45657), aM = e.i(8186); let aE = { general: [{ id: "user", name: "User / Client", icon: au, color: "text-slate-200", category: "Actors" }, { id: "internet", name: "Internet", icon: aa.Globe, color: "text-blue-300", category: "Network" }, { id: "load-balancer", name: "Load Balancer", icon: ag, color: "text-blue-400", category: "Network" }, { id: "firewall", name: "Firewall", icon: ar.Shield, color: "text-red-400", category: "Security" }], aws: [{ id: "ec2", name: "EC2", icon: al.Server, color: "text-orange-400", category: "Compute" }, { id: "lambda", name: "Lambda", icon: ao.Zap, color: "text-yellow-400", category: "Compute" }, { id: "ecs", name: "ECS", icon: ah, color: "text-orange-500", category: "Compute" }, { id: "app-runner", name: "App Runner", icon: am.Cpu, color: "text-blue-400", category: "Compute" }, { id: "s3", name: "S3", icon: ai, color: "text-emerald-400", category: "Storage" }, { id: "ebs", name: "EBS", icon: af, color: "text-emerald-500", category: "Storage" }, { id: "rds", name: "RDS", icon: ai, color: "text-blue-400", category: "Database" }, { id: "dynamodb", name: "DynamoDB", icon: ai, color: "text-purple-400", category: "Database" }, { id: "elasticache", name: "ElastiCache", icon: ag, color: "text-red-400", category: "Database" }, { id: "vpc", name: "VPC", icon: aa.Globe, color: "text-purple-400", category: "Network" }, { id: "route53", name: "Route 53", icon: aa.Globe, color: "text-blue-600", category: "Network" }, { id: "cloudfront", name: "CloudFront", icon: ag, color: "text-blue-500", category: "Network" }, { id: "api-gateway", name: "API Gateway", icon: ao.Zap, color: "text-orange-400", category: "Network" }, { id: "sqs", name: "SQS", icon: ay, color: "text-orange-300", category: "Network" }, { id: "sns", name: "SNS", icon: ag, color: "text-orange-300", category: "Network" }, { id: "iam", name: "IAM", icon: ar.Shield, color: "text-red-400", category: "Security" }, { id: "kms", name: "KMS", icon: ap, color: "text-red-500", category: "Security" }, { id: "waf", name: "WAF", icon: ar.Shield, color: "text-red-600", category: "Security" }], azure: [{ id: "azure-vm", name: "VM", icon: al.Server, color: "text-blue-500", category: "Compute" }, { id: "azure-functions", name: "Functions", icon: ao.Zap, color: "text-yellow-500", category: "Compute" }, { id: "azure-aks", name: "AKS", icon: ah, color: "text-blue-600", category: "Compute" }, { id: "azure-app-service", name: "App Service", icon: aa.Globe, color: "text-blue-400", category: "Compute" }, { id: "azure-blob", name: "Blob Storage", icon: ai, color: "text-blue-400", category: "Storage" }, { id: "azure-disk", name: "Managed Disk", icon: af, color: "text-slate-400", category: "Storage" }, { id: "azure-sql", name: "SQL Database", icon: ai, color: "text-blue-500", category: "Database" }, { id: "azure-cosmos", name: "Cosmos DB", icon: ai, color: "text-emerald-400", category: "Database" }, { id: "azure-vnet", name: "VNet", icon: aa.Globe, color: "text-emerald-500", category: "Network" }, { id: "azure-frontdoor", name: "Front Door", icon: ag, color: "text-blue-500", category: "Network" }, { id: "azure-ad", name: "Active Directory", icon: ar.Shield, color: "text-blue-700", category: "Security" }, { id: "azure-keyvault", name: "Key Vault", icon: ap, color: "text-yellow-500", category: "Security" }], gcp: [{ id: "gcp-ce", name: "Compute Engine", icon: am.Cpu, color: "text-blue-400", category: "Compute" }, { id: "gcp-functions", name: "Cloud Functions", icon: ao.Zap, color: "text-yellow-400", category: "Compute" }, { id: "gcp-gke", name: "GKE", icon: ah, color: "text-blue-500", category: "Compute" }, { id: "gcp-run", name: "Cloud Run", icon: am.Cpu, color: "text-blue-600", category: "Compute" }, { id: "gcp-storage", name: "Cloud Storage", icon: ay, color: "text-blue-400", category: "Storage" }, { id: "gcp-sql", name: "Cloud SQL", icon: ai, color: "text-blue-500", category: "Database" }, { id: "gcp-bigquery", name: "BigQuery", icon: ai, color: "text-blue-700", category: "Database" }, { id: "gcp-vpc", name: "VPC Network", icon: aa.Globe, color: "text-emerald-500", category: "Network" }, { id: "gcp-pubsub", name: "Pub/Sub", icon: ay, color: "text-blue-400", category: "Network" }, { id: "gcp-iam", name: "Cloud IAM", icon: ar.Shield, color: "text-red-400", category: "Security" }, { id: "gcp-kms", name: "Cloud KMS", icon: ap, color: "text-yellow-500", category: "Security" }] }, ak = [{ id: "1", type: "default", data: { label: "Web Server" }, position: { x: 250, y: 5 }, className: "bg-blue-500/10 border-blue-500/50 text-blue-400 font-bold rounded-xl p-4" }, { id: "2", type: "default", data: { label: "RDS Database" }, position: { x: 100, y: 200 }, className: "bg-emerald-500/10 border-emerald-500/50 text-emerald-400 font-bold rounded-xl p-4" }], aC = [{ id: "e1-2", source: "1", target: "2", animated: !0, style: { stroke: "#3b82f6" } }]; function aN() { let [e, t, n] = function (e) { let [t, n] = (0, b.useState)(e), o = (0, b.useCallback)(e => n(t => ri(e, t)), []); return [t, n, o] }(ak), [o, r, i] = function (e) { let [t, n] = (0, b.useState)(e), o = (0, b.useCallback)(e => n(t => ri(e, t)), []); return [t, n, o] }(aC), [a, l] = b.default.useState(""), [s, u] = b.default.useState(!1), c = (0, b.useRef)(null), { screenToFlowPosition: d } = ry(), h = (0, i8.useRouter)(), { token: f } = (0, i9.useAuth)(), p = async () => { u(!0), console.log("Analysis start:", { nodeCount: e.length, hasToken: !!f }); let t = new AbortController, n = setTimeout(() => t.abort(), 2e4); try { let r = x.default.env.NEXT_PUBLIC_API_URL || "https://archshield.onrender.com", i = null; if (f) { console.log("User logged in, fetching/creating project..."); try { let e = await fetch(`${r}/api/v1/projects/`, { headers: { Authorization: `Bearer ${f}`, Accept: "application/json" }, signal: t.signal }); if (e.ok) { let n = await e.json(); if (Array.isArray(n) && n.length > 0) i = n[0].id; else { let e = await fetch(`${r}/api/v1/projects/`, { method: "POST", headers: { Authorization: `Bearer ${f}`, "Content-Type": "application/json" }, body: JSON.stringify({ name: "Designer Project", cloud_provider: "aws", description: "Automatically created from designer" }), signal: t.signal }); e.ok && (i = (await e.json()).id) } } } catch (e) { console.warn("Project fetch/create failed, continuing as guest:", e) } } console.log(`Sending design to: ${r}/api/v1/analysis/design`, { projectId: i }); let a = { "Content-Type": "application/json", Accept: "application/json" }; f && (a.Authorization = `Bearer ${f}`); let l = await fetch(`${r}/api/v1/analysis/design`, { method: "POST", headers: a, body: JSON.stringify({ project_id: i, nodes: e, edges: o }), signal: t.signal }); if (clearTimeout(n), l.ok) { let e = await l.json(); console.log("Analysis successful!", e), h.push("/dashboard/recommendations") } else { let e = await l.text(), t = "The server returned an error."; try { let n = JSON.parse(e); t = n.detail || t, console.error("Analysis API error (JSON):", n) } catch (n) { console.error("Analysis API error (Text):", e), t = `Error ${l.status}: ${e.substring(0, 100)}` } alert(`Analysis failed: ${t}`), u(!1) } } catch (e) { clearTimeout(n), console.error("Analysis process failed:", e), "AbortError" === e.name ? alert("The request timed out. Please check if the backend server is running.") : alert(`Error: ${e.message || "Could not connect to the analysis server."}`), u(!1) } }, g = (0, b.useCallback)(e => r(t => nU({ ...e, animated: !0, style: { stroke: "#3b82f6" } }, t)), [r]), m = (0, b.useCallback)(e => { e.preventDefault(), e.dataTransfer.dropEffect = "move" }, []), y = (0, b.useCallback)(e => { e.preventDefault(); let n = e.dataTransfer.getData("application/reactflow"), o = e.dataTransfer.getData("application/reactflow-label"); if (void 0 === n || !n) return; let r = d({ x: e.clientX, y: e.clientY }); r.x -= 50, r.y -= 25; let i = { id: Math.random().toString(36).substr(2, 9), type: "default", position: r, data: { label: o || n.toUpperCase() }, className: "bg-blue-500/10 border-blue-500/50 text-blue-400 font-bold rounded-xl p-4 min-w-[120px] text-center shadow-lg backdrop-blur-sm" }; t(e => e.concat(i)) }, [d, t]); return (0, v.jsxs)("div", { className: "flex flex-col h-[calc(100vh-120px)] animate-in fade-in duration-700", children: [(0, v.jsxs)("div", { className: "flex items-center justify-between p-4 bg-slate-900 border border-white/10 rounded-t-xl mb-px", children: [(0, v.jsxs)("div", { className: "flex items-center gap-4", children: [(0, v.jsxs)("div", { className: "flex items-center gap-2 mr-4", children: [(0, v.jsx)("h2", { className: "text-xl font-bold text-white", children: "Project: E-commerce V2" }), (0, v.jsx)(ab.Badge, { variant: "outline", className: "border-blue-500/30 text-blue-400 bg-blue-500/5", children: "Draft" })] }), (0, v.jsxs)("div", { className: "flex items-center bg-slate-800 rounded-lg p-1", children: [(0, v.jsx)(aw.TooltipProvider, { children: (0, v.jsxs)(aw.Tooltip, { children: [(0, v.jsx)(aw.TooltipTrigger, { asChild: !0, children: (0, v.jsx)(av.Button, { variant: "ghost", size: "icon", className: "h-8 w-8 text-blue-400 bg-blue-500/10", children: (0, v.jsx)(au, { className: "h-4 w-4" }) }) }), (0, v.jsx)(aw.TooltipContent, { children: "Select" })] }) }), (0, v.jsx)(aw.TooltipProvider, { children: (0, v.jsxs)(aw.Tooltip, { children: [(0, v.jsx)(aw.TooltipTrigger, { asChild: !0, children: (0, v.jsx)(av.Button, { variant: "ghost", size: "icon", className: "h-8 w-8 text-slate-500 hover:text-white", children: (0, v.jsx)(as.Plus, { className: "h-4 w-4" }) }) }), (0, v.jsx)(aw.TooltipContent, { children: "Add Component" })] }) })] })] }), (0, v.jsxs)("div", { className: "flex items-center gap-3", children: [(0, v.jsxs)(av.Button, { variant: "outline", className: "border-white/10 bg-white/5 hover:bg-white/10 text-white gap-2", onClick: () => alert("Design saved to local storage!"), children: [(0, v.jsx)(ae, { className: "w-4 h-4" }), "Save"] }), (0, v.jsxs)(av.Button, { variant: "outline", className: "border-white/10 bg-white/5 hover:bg-white/10 text-white gap-2", onClick: () => alert("Exporting to Terraform... Check downloads."), children: [(0, v.jsx)(ac.Download, { className: "w-4 h-4" }), "Export"] }), (0, v.jsx)("div", { className: "w-[1px] h-6 bg-white/10 mx-2" }), (0, v.jsx)(av.Button, { disabled: s, onClick: p, className: "bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white gap-2 px-6", children: s ? (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(ax.Loader2, { className: "w-4 h-4 animate-spin" }), "Analyzing..."] }) : (0, v.jsxs)(v.Fragment, { children: [(0, v.jsx)(at, { className: "w-4 h-4" }), "Analyze Design"] }) })] })] }), (0, v.jsxs)("div", { className: "flex-1 flex overflow-hidden", children: [(0, v.jsxs)("div", { className: "w-72 bg-slate-900 border border-white/10 border-r-0 flex flex-col", children: [(0, v.jsx)("div", { className: "p-4 border-b border-white/5", children: (0, v.jsxs)("h3", { className: "text-sm font-bold text-white uppercase tracking-widest flex items-center gap-2", children: [(0, v.jsx)(an.Cloud, { className: "w-4 h-4 text-blue-400" }), "Components"] }) }), (0, v.jsx)("div", { className: "px-4 pt-4", children: (0, v.jsxs)("div", { className: "relative", children: [(0, v.jsx)(aM.Search, { className: "absolute left-2.5 top-2.5 h-4 w-4 text-slate-500" }), (0, v.jsx)(a_.Input, { type: "search", placeholder: "Search components...", className: "pl-9 bg-slate-950 border-white/5 text-xs h-9 rounded-lg focus:ring-blue-500/50", value: a, onChange: e => l(e.target.value) })] }) }), (0, v.jsxs)(aS.Tabs, { defaultValue: "aws", className: "flex-1 flex flex-col overflow-hidden", children: [(0, v.jsx)("div", { className: "px-4 pt-4", children: (0, v.jsxs)(aS.TabsList, { className: "w-full bg-slate-950 border border-white/5 p-1 h-9", children: [(0, v.jsx)(aS.TabsTrigger, { value: "general", className: "flex-1 text-[10px] font-bold uppercase tracking-widest data-[state=active]:bg-slate-700/50 data-[state=active]:text-white", children: "Basics" }), (0, v.jsx)(aS.TabsTrigger, { value: "aws", className: "flex-1 text-[10px] font-bold uppercase tracking-widest data-[state=active]:bg-orange-500/20 data-[state=active]:text-orange-400", children: "AWS" }), (0, v.jsx)(aS.TabsTrigger, { value: "azure", className: "flex-1 text-[10px] font-bold uppercase tracking-widest data-[state=active]:bg-blue-500/20 data-[state=active]:text-blue-400", children: "Azure" }), (0, v.jsx)(aS.TabsTrigger, { value: "gcp", className: "flex-1 text-[10px] font-bold uppercase tracking-widest data-[state=active]:bg-red-500/20 data-[state=active]:text-red-400", children: "GCP" })] }) }), (0, v.jsxs)("div", { className: "flex-1 overflow-y-auto p-4 custom-scrollbar", children: [Object.entries(aE).map(([e, t]) => (0, v.jsxs)(aS.TabsContent, { value: e, className: "mt-0 space-y-6 animate-in fade-in slide-in-from-left-2 duration-300", children: [["Actors", "Compute", "Storage", "Database", "Network", "Security"].map(e => { let n = t.filter(t => t.category === e && (t.name.toLowerCase().includes(a.toLowerCase()) || t.category.toLowerCase().includes(a.toLowerCase()))); return 0 === n.length ? null : (0, v.jsxs)("div", { className: "space-y-2", children: [(0, v.jsx)("p", { className: "text-[10px] font-bold text-slate-500 uppercase tracking-widest pl-1", children: e }), (0, v.jsx)("div", { className: "grid grid-cols-1 gap-2", children: n.map(e => (0, v.jsxs)("div", { draggable: !0, onDragStart: t => { t.dataTransfer.setData("application/reactflow", e.id), t.dataTransfer.setData("application/reactflow-label", e.name), t.dataTransfer.effectAllowed = "move" }, className: "flex items-center gap-3 p-3 rounded-xl bg-white/5 border border-white/5 hover:border-blue-500/50 hover:bg-white/10 transition-all cursor-grab active:cursor-grabbing group", children: [(0, v.jsx)("div", { className: "w-8 h-8 rounded-lg bg-slate-800 flex items-center justify-center group-hover:scale-110 transition-transform", children: (0, v.jsx)(e.icon, { className: `w-4 h-4 ${e.color}` }) }), (0, v.jsx)("div", { children: (0, v.jsx)("p", { className: "text-xs font-semibold text-white group-hover:text-blue-400 transition-colors", children: e.name }) })] }, e.id)) })] }, e) }), a && t.every(e => !e.name.toLowerCase().includes(a.toLowerCase())) && (0, v.jsx)("div", { className: "text-center py-8", children: (0, v.jsxs)("p", { className: "text-xs text-slate-500 italic", children: ["No matches in ", e.toUpperCase()] }) })] }, e)), (0, v.jsxs)("div", { className: "mt-8 p-4 rounded-xl bg-blue-500/5 border border-blue-500/10 italic text-[10px] text-slate-400 leading-relaxed", children: [(0, v.jsx)(ad.Info, { className: "w-3 h-3 text-blue-400 mb-2 inline-block mr-1" }), "Drag any component onto the canvas. Use the logic to build complex cloud infrastructures."] })] })] })] }), (0, v.jsx)("div", { className: "flex-1 relative bg-slate-950/50", ref: c, children: (0, v.jsxs)(iI, { nodes: e, edges: o, onNodesChange: n, onEdgesChange: i, onConnect: g, onDrop: y, onDragOver: m, fitView: !0, style: { width: "100%", height: "100%" }, colorMode: "dark", children: [(0, v.jsx)(iV, { color: "#1e293b", gap: 20 }), (0, v.jsx)(iU, { className: "bg-slate-900 border-white/10" }), (0, v.jsx)(i4, { className: "bg-slate-900 border-white/10", nodeColor: e => "default" === e.type ? "#3b82f6" : "#1e293b", maskColor: "rgba(15, 23, 42, 0.7)" })] }) })] })] }) } function aA() { return (0, v.jsx)(iz, { children: (0, v.jsx)(aN, {}) }) } e.s(["default", () => aA], 11477)
}]);
